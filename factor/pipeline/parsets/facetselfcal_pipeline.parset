pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, {% if preapply_phase_cal %} expand_preapply_parmdb_map, {% endif %} shift_cal, {% if preapply_phase_cal %} shift_cal_dir_indep, {% endif %} create_compressed_mapfile_data, sort_into_Groups, sort_into_Groups_maps, concat_data, {% if pre_average %} regroup_shift_cal, regroup_parmdb, pre_average, make_blavg_data_mapfile, concat_blavg_data, {% endif %} {% if selfcal_local_dir is not none %} make_concat_data_sync_mapfile, adjust_concat_data_hosts, sync_concat_data_to_local, {% if pre_average %} make_concat_blavg_data_sync_mapfile, adjust_concat_blavg_data_hosts, sync_concat_blavg_data_to_local, {% endif %} {% endif %} concat_data_compressed_mapfile, {% block selfcal_steps %} {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image01, create_imagebase_map01, adjust_wsclean_mapfile0, mask0, wsclean_image02, create_imagebase_map02, pad_selfcal_model0_images, regroup_concat_data_map, create_expanded_model0_mapfile, expand_selfcal_model_size_map, wsclean_ft0, {% if pre_average %} copy_model_data0, {% endif %} make_fast_phase_parmdb_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% endif %} remove_parmdbs1, solve_phaseonly1, merge_first_phase_parmdbs, {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image11, create_imagebase_map11, adjust_wsclean_mapfile11, mask1, wsclean_image12, create_imagebase_map12, create_expanded_model1_mapfile, pad_selfcal_model1_images, wsclean_ft1, {% if pre_average %} copy_model_data1, {% endif %} remove_parmdbs2, solve_phaseonly2, apply_phaseonly2, create_compressed_mapfile2, wsclean_image21, create_imagebase_map21, adjust_wsclean_mapfile21, mask2, wsclean_image22, create_imagebase_map22, create_expanded_model2_mapfile, pad_selfcal_model2_images, wsclean_ft2, {% if pre_average %} copy_model_data2, {% endif %} remove_parmdbs11, solve_ampphase11, apply_ampphase11, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs1, smooth_amp1, expand_smoothed_amp1_parmdb_map, apply_amp1, create_compressed_mapfile3, wsclean_image31, create_imagebase_map31, adjust_wsclean_mapfile31, mask3, wsclean_image32, loop_ampcal, {% endblock selfcal_steps %} {% if selfcal_local_dir is not none %} remove_concat_data, {% endif %} merge_selfcal_parmdbs, {% if create_preapply_parmdb %} create_preapply_parmdb, {% endif %} convert_merged_selfcal_parmdbs, make_selfcal_plots, create_selfcal_images_mapfile, make_selfcal_images, expand_merged_parmdb_map, create_model4_map, blank_model, expand_blank_model_map, make_new_cal_skymodel, {% if not is_patch %} make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, {% if use_wideband %} select_imaging_bands, select_sourcedb_all_facet_sources, select_parmdb_map, select_merged_parmdb_map, {% endif %} apply_dir_dep, create_compressed_mapfile5, premask, wsclean_image_full, create_imagebase_map, adjust_wsclean_mapfile1, mask5, create_model5_map, adjust_wsclean_mapfile2, expand_model5_map, expand_mask5_map, make_new_facet_skymodel, make_old_facet_skymodels_minus_cal, combine_skymodels, make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% else %} make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% endif %} predict_and_difference_models, create_middle_band_mapfile1, create_middle_band_mapfile2, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind        = plugin
create_parmdb_map.control.type        = addListMapfile
create_parmdb_map.control.hosts       = {{ hosts }}
create_parmdb_map.control.files       = {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir = input.output.mapfile_dir
create_parmdb_map.control.filename    = dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind        = plugin
create_full_skymodels_map.control.type        = addListMapfile
create_full_skymodels_map.control.hosts       = {{ hosts }}
create_full_skymodels_map.control.files       = {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir = input.output.mapfile_dir
create_full_skymodels_map.control.filename    = full_skymodels.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type       = make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey   = fullmodelfile
make_facet_skymodels_cal.control.outputkey  = outfile
make_facet_skymodels_cal.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only  = True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type       = make_sourcedb
make_sourcedb_cal_facet_sources.control.mapfile_in = make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.inputkey   = in
make_sourcedb_cal_facet_sources.argument.format    = <
make_sourcedb_cal_facet_sources.argument.outtype   = blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind           = plugin
expand_sourcedb_cal_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in     = make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename       = expand_sourcedb_cal_facet_sources.mapfile

{% if preapply_phase_cal %}
# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_preapply_parmdb_map.control.kind             = plugin
expand_preapply_parmdb_map.control.type             = expandMapfile
expand_preapply_parmdb_map.control.mapfile_in       = {{ preapply_parmdb_mapfile }}
expand_preapply_parmdb_map.control.mapfile_to_match = create_ms_map.output.mapfile
expand_preapply_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_preapply_parmdb_map.control.filename         = expand_preapply_parmdbs.mapfile
{% endif %}

# shift data to calibrator position, predict and add calibrator sources, and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                 = dppp
{% if preapply_phase_cal %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb,preapply_parmdb]
{% else %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb]
{% endif %}
shift_cal.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                     = True
shift_cal.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
{% if flag_reltime is not none or flag_baseline is not none %}
shift_cal.argument.steps                               = [shift,add,flag,correct_fast1,correct_fast2,correct_slow,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,correct_fast1,correct_fast2,correct_slow,avg]
{% endif %}
shift_cal.argument.correct_fast1.type                  = applycal
shift_cal.argument.correct_fast1.parmdb                = preapply_parmdb
shift_cal.argument.correct_fast1.correction            = tec
shift_cal.argument.correct_fast1.invert                = True
shift_cal.argument.correct_fast2.type                  = applycal
shift_cal.argument.correct_fast2.parmdb                = preapply_parmdb
shift_cal.argument.correct_fast2.correction            = commonscalarphase
shift_cal.argument.correct_fast2.invert                = True
shift_cal.argument.correct_slow.type                   = applycal
shift_cal.argument.correct_slow.parmdb                 = preapply_parmdb
shift_cal.argument.correct_slow.invert                 = True
{% else %}
{% if flag_reltime is not none or flag_baseline is not none %}
shift_cal.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,avg]
{% endif %}
{% endif %}
shift_cal.argument.shift.type                          = phaseshifter
shift_cal.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                            = predict
shift_cal.argument.add.sourcedb                        = sourcedb
shift_cal.argument.add.operation                       = add
shift_cal.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_reltime is not none or flag_baseline is not none %}
shift_cal.argument.flag.type                           = preflagger
{% endif %}
{% if flag_reltime is not none %}
shift_cal.argument.flag.reltime                        = {{ flag_reltime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal.argument.flag.baseline                       = {{ flag_baseline }}
{% endif %}
shift_cal.argument.avg.type                            = squash
shift_cal.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                        = 1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                = "Dysco"
shift_cal.argument.msout.storagemanager.databitrate    = 16
shift_cal.argument.msout.storagemanager.weightbitrate  = 12
shift_cal.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation = 1.5
shift_cal.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if preapply_phase_cal %}
# If we preapplied solutions above, we also need a dir-indep corrected   // length = nfiles
# version of the shift_cal data for the initial selfcal image
# Compress both data and weights
shift_cal_dir_indep.control.type                                 = dppp
shift_cal_dir_indep.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal_dir_indep.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb]
shift_cal_dir_indep.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal_dir_indep.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal_dir_indep.argument.msout.overwrite                     = True
shift_cal_dir_indep.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal_dir_indep.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_reltime is not none or flag_baseline is not none %}
shift_cal_dir_indep.argument.steps                               = [shift,add,flag,correct,avg]
{% else %}
shift_cal_dir_indep.argument.steps                               = [shift,add,correct,avg]
{% endif %}
shift_cal_dir_indep.argument.shift.type                          = phaseshifter
shift_cal_dir_indep.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal_dir_indep.argument.add.type                            = predict
shift_cal_dir_indep.argument.add.sourcedb                        = sourcedb
shift_cal_dir_indep.argument.add.operation                       = add
shift_cal_dir_indep.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_reltime is not none or flag_baseline is not none %}
shift_cal_dir_indep.argument.flag.type                           = preflagger
{% endif %}
{% if flag_reltime is not none %}
shift_cal_dir_indep.argument.flag.reltime                        = {{ flag_reltime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal_dir_indep.argument.flag.baseline                       = {{ flag_baseline }}
{% endif %}
shift_cal_dir_indep.argument.correct.type                        = applycal
shift_cal_dir_indep.argument.correct.parmdb                      = dir_indep_parmdb
shift_cal_dir_indep.argument.correct.correction                  = gain
shift_cal_dir_indep.argument.correct.invert                      = True
shift_cal_dir_indep.argument.avg.type                            = squash
shift_cal_dir_indep.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal_dir_indep.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
shift_cal_dir_indep.argument.msout.storagemanager                = "Dysco"
shift_cal_dir_indep.argument.msout.storagemanager.databitrate    = 16
shift_cal_dir_indep.argument.msout.storagemanager.weightbitrate  = 12
shift_cal_dir_indep.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal_dir_indep.argument.msout.storagemanager.disttruncation = 1.5
shift_cal_dir_indep.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_data.control.kind        = plugin
create_compressed_mapfile_data.control.type        = compressMapfile
create_compressed_mapfile_data.control.mapfile_in  = shift_cal.output.mapfile
create_compressed_mapfile_data.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_data.control.filename    = concat_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                 = sort_times_into_freqGroups
sort_into_Groups.argument.flags               = [create_compressed_mapfile_data.output.mapfile]
sort_into_Groups.argument.filename            = sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir         = input.output.mapfile_dir
sort_into_Groups.argument.hosts               = {{ hosts }}
sort_into_Groups.argument.stepname            = sort_into_Groups
sort_into_Groups.argument.enforce_numSB       = False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB               = {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad           = {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files    = True
sort_into_Groups.argument.skip_flagged_groups = False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind             = plugin
sort_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap = sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap = sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                 = dppp_concat
concat_data.control.mapfile_out                          = sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             = msin
concat_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     = DATA
concat_data.argument.msin.missingdata                    = True
concat_data.argument.msin.orderms                        = False
concat_data.argument.msout.overwrite                     = True
concat_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_data.argument.steps                               = []
{% if use_compression %}
concat_data.argument.msout.storagemanager                = "Dysco"
concat_data.argument.msout.storagemanager.databitrate    = 16
concat_data.argument.msout.storagemanager.weightbitrate  = 12
concat_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation = 1.5
concat_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if pre_average %}
# re-group shift_cal mapfile to have one group per band, length = nbands
regroup_shift_cal.control.kind           = plugin
regroup_shift_cal.control.type           = reGroupMapfile
regroup_shift_cal.control.mapfile_in     = shift_cal.output.mapfile
regroup_shift_cal.control.mapfile_groups = create_msmulti_map.output.mapfile
regroup_shift_cal.control.mapfile_dir    = input.output.mapfile_dir
regroup_shift_cal.control.filename       = regroup_shift_cal.mapfile

# re-group dir-independent parmdb mapfile to have one group per band, length = nbands
regroup_parmdb.control.kind           = plugin
regroup_parmdb.control.type           = reGroupMapfile
regroup_parmdb.control.mapfile_in     = create_parmdb_map.output.mapfile
regroup_parmdb.control.mapfile_groups = create_msmulti_map.output.mapfile
regroup_parmdb.control.check_basename = False
regroup_parmdb.control.mapfile_dir    = input.output.mapfile_dir
regroup_parmdb.control.filename       = re_grouped_parmdb.mapfile

# Do the baseline-dependent preaveraging, length = nbands
# This step makes new columns named BLAVG_DATA and BLAVG_WEIGHT_SPECTRUM
pre_average.control.type        = pre_average
pre_average.control.mapfiles_in = [regroup_shift_cal.output.mapfile,regroup_parmdb.output.mapfile]
pre_average.control.inputkeys   = [datafiles,parmdbs]
pre_average.argument.flags      = [datafiles,parmdbs,DATA,DATA,WEIGHT_SPECTRUM,{{ target_rms_rad }}]

# make mapfile for concatenated preaveraged data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind               = plugin
make_blavg_data_mapfile.control.type               = createMapfile
make_blavg_data_mapfile.control.method             = add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in         = sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file = "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir        = input.output.mapfile_dir
make_blavg_data_mapfile.control.filename           = make_blavg_data.mapfile

# Concat the preaveraged data (and weights), length = ntimes * num_cal_blocks
# Compress both data and weights
concat_blavg_data.control.type                                 = dppp_concat
concat_blavg_data.control.mapfile_out                          = make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                             = msin
concat_blavg_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_blavg_data.argument.msin.datacolumn                     = DATA
concat_blavg_data.argument.msin.missingdata                    = True
concat_blavg_data.argument.msin.orderms                        = False
concat_blavg_data.argument.msout.overwrite                     = True
concat_blavg_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_blavg_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_blavg_data.argument.steps                               = []
{% if use_compression %}
concat_blavg_data.argument.msout.storagemanager                = "Dysco"
concat_blavg_data.argument.msout.storagemanager.databitrate    = 16
concat_blavg_data.argument.msout.storagemanager.weightbitrate  = 12
concat_blavg_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_blavg_data.argument.msout.storagemanager.disttruncation = 1.5
concat_blavg_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

{% if selfcal_local_dir is not none %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind            = plugin
make_concat_data_sync_mapfile.control.type            = changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in      = concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename        = concat_data_local.mapfile
make_concat_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_data_hosts.control.kind             = plugin
adjust_concat_data_hosts.control.type             = matchHosts
adjust_concat_data_hosts.control.mapfile_in       = concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match = make_concat_data_sync_mapfile.output.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type        = sync_files
sync_concat_data_to_local.control.mapfile_in  = concat_data.output.mapfile
sync_concat_data_to_local.control.mapfile_out = make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey    = msin
sync_concat_data_to_local.control.outputkey   = msout
sync_concat_data_to_local.argument.flags      = [msin,msout]

{% if pre_average %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_blavg_data_sync_mapfile.control.kind            = plugin
make_concat_blavg_data_sync_mapfile.control.type            = changeDirectory
make_concat_blavg_data_sync_mapfile.control.mapfile_in      = concat_blavg_data.output.mapfile
make_concat_blavg_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_blavg_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_blavg_data_sync_mapfile.control.filename        = concat_blavg_data_local.mapfile
make_concat_blavg_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_blavg_data_hosts.control.kind             = plugin
adjust_concat_blavg_data_hosts.control.type             = matchHosts
adjust_concat_blavg_data_hosts.control.mapfile_in       = concat_blavg_data.output.mapfile
adjust_concat_blavg_data_hosts.control.mapfile_to_match = make_concat_blavg_data_sync_mapfile.output.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_blavg_data_to_local.control.type        = sync_files
sync_concat_blavg_data_to_local.control.mapfile_in  = concat_blavg_data.output.mapfile
sync_concat_blavg_data_to_local.control.mapfile_out = make_concat_blavg_data_sync_mapfile.output.mapfile
sync_concat_blavg_data_to_local.control.inputkey    = msin
sync_concat_blavg_data_to_local.control.outputkey   = msout
sync_concat_blavg_data_to_local.argument.flags      = [msin,msout]
{% endif %}
{% endif %}

# make compressed mapfile for (non-local) concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind        = plugin
concat_data_compressed_mapfile.control.type        = compressMapfile
concat_data_compressed_mapfile.control.mapfile_in  = concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename    = concat_chunks_input.mapfile

{% block selfcal_parameters %}
########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                 = dppp
average0.control.mapfiles_in                          = [shift_cal.output.mapfile,create_parmdb_map.output.mapfile]
average0.control.inputkeys                            = [msin,parmdb]
average0.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                     = DATA
average0.argument.msout.overwrite                     = True
average0.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average0.argument.steps                               = [correct,avg]
average0.argument.correct.type                        = applycal
average0.argument.correct.parmdb                      = parmdb
average0.argument.correct.correction                  = gain
average0.argument.correct.invert                      = True
average0.argument.avg.type                            = squash
average0.argument.avg.freqstep                        = 1
average0.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                = "Dysco"
average0.argument.msout.storagemanager.databitrate    = 16
average0.argument.msout.storagemanager.weightbitrate  = 12
average0.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation = 1.5
average0.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind        = plugin
create_compressed_mapfile0.control.type        = compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in  = shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in  = average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile0.control.filename    = concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type           = sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags         = [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename      = sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir   = input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts         = {{ hosts }}
sort_average0_into_Groups.argument.stepname      = sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB = False
sort_average0_into_Groups.argument.nband_pad     = {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind             = plugin
sort_average0_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap = sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap = sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 = dppp_concat
concat_average0_data.control.mapfile_out                          = sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           = sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             = msin
concat_average0_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     = DATA
concat_average0_data.argument.msin.missingdata                    = True
concat_average0_data.argument.msin.orderms                        = False
concat_average0_data.argument.msout.overwrite                     = True
concat_average0_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               = []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                = "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    = 16
concat_average0_data.argument.msout.storagemanager.weightbitrate  = 12
concat_average0_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation = 1.5
concat_average0_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind        = plugin
create_compressed_mapfile01.control.type        = compressMapfile
create_compressed_mapfile01.control.mapfile_in  = concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile01.control.filename    = image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                   = make_clean_mask
premask_selfcal.control.mapfile_in             = create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey               = imagefile
premask_selfcal.control.outputkey              = maskfile
premask_selfcal.argument.flags                 = [imagefile,maskfile]
premask_selfcal.argument.img_format            = fits
premask_selfcal.argument.pad_to_size           = {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection = True
premask_selfcal.argument.vertices_file         = {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg      = {{ ra }}
premask_selfcal.argument.reference_dec_deg     = {{ dec }}
premask_selfcal.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file           = {{ region_selfcal }}
premask_selfcal.argument.make_blank_image      = True
premask_selfcal.argument.trim_by               = 0.4

# image the concatenated data with wsclean, length = 1
wsclean_image01.control.type                    = wsclean
wsclean_image01.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image01.control.inputkeys               = [msfile,fitsmask]
wsclean_image01.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image01.argument.fitsmask               = fitsmask
wsclean_image01.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image01.argument.niter                  = 1000
wsclean_image01.argument.threshold              = 0.0
wsclean_image01.argument.pol                    = I
wsclean_image01.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image01.argument.mgain                  = 0.6
wsclean_image01.argument.cleanborder            = 0
wsclean_image01.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image01.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image01.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image01.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image01.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image01.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image01.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image01.argument.deconvolution-channels = 3
wsclean_image01.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image01.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image01.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map01.control.kind        = plugin
create_imagebase_map01.control.type        = trimMapfile
create_imagebase_map01.control.mapfile_in  = wsclean_image01.output.wsclean_image01-image.fits.mapfile
create_imagebase_map01.control.trim        = -
create_imagebase_map01.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map01.control.filename    = wsclean_image01_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile0.control.kind        = plugin
adjust_wsclean_mapfile0.control.type        = appendMapfile
adjust_wsclean_mapfile0.control.mapfile_in  = create_imagebase_map01.output.mapfile
adjust_wsclean_mapfile0.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile0.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile0.control.filename    = wsclean_image01_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask0.control.type                    = make_clean_mask
mask0.control.mapfile_in              = adjust_wsclean_mapfile0.output.mapfile
mask0.control.inputkey                = imagefile
mask0.control.outputkey               = maskfile
mask0.argument.flags                  = [imagefile,maskfile]
mask0.argument.region_file            = {{ region_selfcal }}
mask0.argument.threshpix              = 10
mask0.argument.threshisl              = 6
mask0.argument.iterate_threshold      = True
mask0.argument.atrous_do              = {{ atrous_do }}
mask0.argument.rmsbox                 = (80,20)
mask0.argument.adaptive_rmsbox        = True
mask0.argument.trim_by                = 0.4
mask0.argument.img_format             = fits
mask0.argument.threshold_format       = float
mask0.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the concatenated data again with wsclean, length = 1
wsclean_image02.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile,mask0.output.threshold_5sig.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image02.argument.threshold              = threshold
wsclean_image02.argument.niter                  = 10000
{% else %}
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask]
wsclean_image02.argument.threshold              = 0.0
wsclean_image02.argument.niter                  = 1000
{% endif %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image02.argument.fitsmask               = fitsmask
wsclean_image02.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.pol                    = I
wsclean_image02.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                  = 0.6
wsclean_image02.argument.cleanborder            = 0
wsclean_image02.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image02.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image02.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image02.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image02.argument.deconvolution-channels = 3
wsclean_image02.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image02.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map02.control.kind        = plugin
create_imagebase_map02.control.type        = trimMapfile
create_imagebase_map02.control.mapfile_in  = wsclean_image02.output.wsclean_image02-image.fits.mapfile
create_imagebase_map02.control.trim        = -
create_imagebase_map02.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map02.control.filename    = image02_rootname.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model0_images.control.type       = pad_image
pad_selfcal_model0_images.control.mapfile_in = create_imagebase_map02.output.mapfile
pad_selfcal_model0_images.control.inputkey   = imagefile
pad_selfcal_model0_images.argument.flags     = [imagefile]

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind               = plugin
regroup_concat_data_map.control.type               = compressMapfile
regroup_concat_data_map.control.mapfile_in         = {{ concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress = {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir        = input.output.mapfile_dir
regroup_concat_data_map.control.filename           = regroup_concat_data.mapfile

# expand the mapfile of the model image to match ft files, length = ntimes
create_expanded_model0_mapfile.control.kind             = plugin
create_expanded_model0_mapfile.control.type             = expandMapfile
create_expanded_model0_mapfile.control.mapfile_in       = create_imagebase_map02.output.mapfile
create_expanded_model0_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model0_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model0_mapfile.control.filename         = expand_model0.mapfile

# expand mapfile of the model image sizes to all groups, length = ntimes
expand_selfcal_model_size_map.control.kind             = plugin
expand_selfcal_model_size_map.control.type             = expandMapfile
expand_selfcal_model_size_map.control.mapfile_in       = pad_selfcal_model0_images.output.padsize.mapfile
expand_selfcal_model_size_map.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
expand_selfcal_model_size_map.control.mapfile_dir      = input.output.mapfile_dir
expand_selfcal_model_size_map.control.filename         = expand_selfcal_model_size.mapfile

# predict model visibilities, length = ntimes
wsclean_ft0.control.type         = wsclean_ft
wsclean_ft0.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model0_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft0.control.inputkeys    = [msfile,name,size]
wsclean_ft0.argument.flags       = [-predict,msfile]
wsclean_ft0.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft0.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft0.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft0.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft0.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data0.control.type        =   copy_column
copy_model_data0.control.mapfiles_in =   [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data0.control.inputkeys   =   [ms_from,ms_to]
copy_model_data0.argument.flags      =   [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# generate mapfile for the fast-phase parmDBs generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind               = plugin
make_fast_phase_parmdb_map.control.type               = createMapfile
make_fast_phase_parmdb_map.control.method             = add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file = /instrument
make_fast_phase_parmdb_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename           = fast_parmdb.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs1.control.type       = remove_file
remove_parmdbs1.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs1.control.inputkey   = parmdb
remove_parmdbs1.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly1.control.type                     = dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb,sourcedb]
{% else %}
solve_phaseonly1.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb]
{% endif %}
solve_phaseonly1.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn         = DATA
solve_phaseonly1.argument.msout                   = .
solve_phaseonly1.argument.steps                   = [uvcut,solvetec]
solve_phaseonly1.argument.uvcut.type              = uvwflagger
solve_phaseonly1.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly1.argument.solvetec.type           = gaincal
solve_phaseonly1.argument.solvetec.caltype        = tecandphase
solve_phaseonly1.argument.solvetec.parmdb         = parmdb
{% if peel_skymodel is not none %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = False
solve_phaseonly1.argument.solvetec.sourcedb       = sourcedb
{% else %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = True
{% endif %}
solve_phaseonly1.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_first_phase_parmdbs.control.type       = merge_parmdbs_in_time
merge_first_phase_parmdbs.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_first_phase_parmdbs.control.inputkey   = mslist
merge_first_phase_parmdbs.control.outputkey  = outparmdb
merge_first_phase_parmdbs.argument.flags     = [mslist,instrument,outparmdb]

########## end of first round of selfcal
########## start of second round of selfcal

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the shared disk
make_apply_mapfile.control.kind         = plugin
make_apply_mapfile.control.type         = changeDirectory
make_apply_mapfile.control.mapfile_in   = make_concat_data_sync_mapfile.output.mapfile
make_apply_mapfile.control.new_dir      = {{ pipeline_parset_dir }}
make_apply_mapfile.control.make_tempdir = False
make_apply_mapfile.control.append       = _apply_output
make_apply_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_apply_mapfile.control.filename     = apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 = dppp
apply_phaseonly1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly1.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     = DATA
apply_phaseonly1.argument.msout.overwrite                     = True
apply_phaseonly1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly1.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type                  = applycal
apply_phaseonly1.argument.correct_fast1.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast1.correction            = tec
apply_phaseonly1.argument.correct_fast1.invert                = True
apply_phaseonly1.argument.correct_fast2.type                  = applycal
apply_phaseonly1.argument.correct_fast2.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast2.correction            = commonscalarphase
apply_phaseonly1.argument.correct_fast2.invert                = True
apply_phaseonly1.argument.avg.type                            = squash
apply_phaseonly1.argument.avg.freqstep                        = 1
apply_phaseonly1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                = "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind        = plugin
create_compressed_mapfile1.control.type        = compressMapfile
create_compressed_mapfile1.control.mapfile_in  = apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile1.control.filename    = image1_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image11.control.type                    = wsclean
wsclean_image11.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image11.control.inputkeys               = [msfile,fitsmask]
wsclean_image11.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image11.argument.fitsmask               = fitsmask
wsclean_image11.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image11.argument.niter                  = 1000
wsclean_image11.argument.threshold              = 0.0
wsclean_image11.argument.pol                    = I
wsclean_image11.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image11.argument.mgain                  = 0.6
wsclean_image11.argument.cleanborder            = 0
wsclean_image11.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image11.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image11.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image11.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image11.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image11.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image11.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image11.argument.deconvolution-channels = 3
wsclean_image11.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image11.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image11.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map11.control.kind        = plugin
create_imagebase_map11.control.type        = trimMapfile
create_imagebase_map11.control.mapfile_in  = wsclean_image11.output.wsclean_image11-image.fits.mapfile
create_imagebase_map11.control.trim        = -
create_imagebase_map11.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map11.control.filename    = wsclean_image11_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile11.control.kind        = plugin
adjust_wsclean_mapfile11.control.type        = appendMapfile
adjust_wsclean_mapfile11.control.mapfile_in  = create_imagebase_map11.output.mapfile
adjust_wsclean_mapfile11.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile11.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile11.control.filename    = wsclean_image11_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask1.control.type                    = make_clean_mask
mask1.control.mapfile_in              = adjust_wsclean_mapfile11.output.mapfile
mask1.control.inputkey                = imagefile
mask1.control.outputkey               = maskfile
mask1.argument.flags                  = [imagefile,maskfile]
mask1.argument.region_file            = {{ region_selfcal }}
mask1.argument.threshpix              = 8
mask1.argument.threshisl              = 7
mask1.argument.iterate_threshold      = True
mask1.argument.atrous_do              = {{ atrous_do }}
mask1.argument.rmsbox                 = (80,20)
mask1.argument.adaptive_rmsbox        = True
mask1.argument.trim_by                = 0.4
mask1.argument.img_format             = fits
mask1.argument.threshold_format       = float
mask1.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image12.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile,mask1.output.threshold_5sig.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image12.argument.threshold              = threshold
wsclean_image12.argument.niter                  = 10000
{% else %}
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask]
wsclean_image12.argument.threshold              = 0.0
wsclean_image12.argument.niter                  = 1000
{% endif %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image12.argument.fitsmask               = fitsmask
wsclean_image12.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.pol                    = I
wsclean_image12.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                  = 0.6
wsclean_image12.argument.cleanborder            = 0
wsclean_image12.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image12.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image12.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image12.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image12.argument.deconvolution-channels = 3
wsclean_image12.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image12.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map12.control.kind        = plugin
create_imagebase_map12.control.type        = trimMapfile
create_imagebase_map12.control.mapfile_in  = wsclean_image12.output.wsclean_image12-image.fits.mapfile
create_imagebase_map12.control.trim        = -
create_imagebase_map12.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map12.control.filename    = wsclean_image12_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model1_mapfile.control.kind             = plugin
create_expanded_model1_mapfile.control.type             = expandMapfile
create_expanded_model1_mapfile.control.mapfile_in       = create_imagebase_map12.output.mapfile
create_expanded_model1_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model1_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model1_mapfile.control.filename         = expand_wsclean_model1.mapfile

## pad the model image with zeros, length = 1
pad_selfcal_model1_images.control.type       = pad_image
pad_selfcal_model1_images.control.mapfile_in = create_imagebase_map12.output.mapfile
pad_selfcal_model1_images.control.inputkey   = imagefile
pad_selfcal_model1_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft1.control.type         = wsclean_ft
wsclean_ft1.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model1_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft1.control.inputkeys    = [msfile,name,size]
wsclean_ft1.argument.flags       = [-predict,msfile]
wsclean_ft1.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft1.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft1.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft1.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft1.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data1.control.type        =   copy_column
copy_model_data1.control.mapfiles_in =   [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data1.control.inputkeys   =   [ms_from,ms_to]
copy_model_data1.argument.flags      =   [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs2.control.type       = remove_file
remove_parmdbs2.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs2.control.inputkey   = parmdb
remove_parmdbs2.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly2.control.type                     = dppp_inplace
solve_phaseonly2.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly2.control.inputkeys                = [msin,parmdb]
solve_phaseonly2.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn         = DATA
solve_phaseonly2.argument.msout                   = .
solve_phaseonly2.argument.steps                   = [uvcut,solvetec]
solve_phaseonly2.argument.uvcut.type              = uvwflagger
solve_phaseonly2.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly2.argument.solvetec.type           = gaincal
solve_phaseonly2.argument.solvetec.caltype        = tecandphase
solve_phaseonly2.argument.solvetec.parmdb         = parmdb
solve_phaseonly2.argument.solvetec.usemodelcolumn = True
solve_phaseonly2.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan          = {{ solint_freq_a }}

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                                 = dppp
apply_phaseonly2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly2.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn                     = DATA
apply_phaseonly2.argument.msout.overwrite                     = True
apply_phaseonly2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly2.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly2.argument.correct_fast1.type                  = applycal
apply_phaseonly2.argument.correct_fast1.parmdb                = parmdb
apply_phaseonly2.argument.correct_fast1.correction            = tec
apply_phaseonly2.argument.correct_fast1.invert                = True
apply_phaseonly2.argument.correct_fast2.type                  = applycal
apply_phaseonly2.argument.correct_fast2.parmdb                = parmdb
apply_phaseonly2.argument.correct_fast2.correction            = commonscalarphase
apply_phaseonly2.argument.correct_fast2.invert                = True
apply_phaseonly2.argument.avg.type                            = squash
apply_phaseonly2.argument.avg.freqstep                        = 1
apply_phaseonly2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly2.argument.msout.storagemanager                = "Dysco"
apply_phaseonly2.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly2.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly2.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind        = plugin
create_compressed_mapfile2.control.type        = compressMapfile
create_compressed_mapfile2.control.mapfile_in  = apply_phaseonly2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile2.control.filename    = image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image21.control.type                    = wsclean
wsclean_image21.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image21.control.inputkeys               = [msfile,fitsmask]
wsclean_image21.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image21.argument.fitsmask               = fitsmask
wsclean_image21.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image21.argument.niter                  = 1000
wsclean_image21.argument.threshold              = 0.0
wsclean_image21.argument.pol                    = I
wsclean_image21.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image21.argument.mgain                  = 0.6
wsclean_image21.argument.cleanborder            = 0
wsclean_image21.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image21.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image21.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image21.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image21.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image21.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image21.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels = 3
wsclean_image21.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image21.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image21.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map21.control.kind        = plugin
create_imagebase_map21.control.type        = trimMapfile
create_imagebase_map21.control.mapfile_in  = wsclean_image21.output.wsclean_image21-image.fits.mapfile
create_imagebase_map21.control.trim        = -
create_imagebase_map21.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map21.control.filename    = wsclean_image21_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile21.control.kind        = plugin
adjust_wsclean_mapfile21.control.type        = appendMapfile
adjust_wsclean_mapfile21.control.mapfile_in  = create_imagebase_map21.output.mapfile
adjust_wsclean_mapfile21.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile21.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile21.control.filename    = wsclean_image21_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask2.control.type                    = make_clean_mask
mask2.control.mapfile_in              = adjust_wsclean_mapfile21.output.mapfile
mask2.control.inputkey                = imagefile
mask2.control.outputkey               = maskfile
mask2.argument.flags                  = [imagefile,maskfile]
mask2.argument.region_file            = {{ region_selfcal }}
mask2.argument.threshpix              = 8
mask2.argument.threshisl              = 7
mask2.argument.iterate_threshold      = True
mask2.argument.atrous_do              = {{ atrous_do }}
mask2.argument.rmsbox                 = (80,20)
mask2.argument.adaptive_rmsbox        = True
mask2.argument.trim_by                = 0.4
mask2.argument.img_format             = fits
mask2.argument.threshold_format       = float
mask2.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image22.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile,mask2.output.threshold_5sig.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image22.argument.threshold              = threshold
wsclean_image22.argument.niter                  = 10000
{% else %}
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask]
wsclean_image22.argument.threshold              = 0.0
wsclean_image22.argument.niter                  = 1000
{% endif %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image22.argument.fitsmask               = fitsmask
wsclean_image22.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.pol                    = I
wsclean_image22.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                  = 0.6
wsclean_image22.argument.cleanborder            = 0
wsclean_image22.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image22.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image22.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image22.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image22.argument.deconvolution-channels = 3
wsclean_image22.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image22.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind        = plugin
create_imagebase_map22.control.type        = trimMapfile
create_imagebase_map22.control.mapfile_in  = wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim        = -
create_imagebase_map22.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map22.control.filename    = wsclean_image22_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model2_mapfile.control.kind             = plugin
create_expanded_model2_mapfile.control.type             = expandMapfile
create_expanded_model2_mapfile.control.mapfile_in       = create_imagebase_map22.output.mapfile
create_expanded_model2_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model2_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model2_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model2_images.control.type       = pad_image
pad_selfcal_model2_images.control.mapfile_in = create_imagebase_map22.output.mapfile
pad_selfcal_model2_images.control.inputkey   = imagefile
pad_selfcal_model2_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft2.control.type         = wsclean_ft
wsclean_ft2.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model2_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft2.control.inputkeys    = [msfile,name,size]
wsclean_ft2.argument.flags       = [-predict,msfile]
wsclean_ft2.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft2.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft2.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft2.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft2.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data2.control.type        =   copy_column
copy_model_data2.control.mapfiles_in =   [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data2.control.inputkeys   =   [ms_from,ms_to]
copy_model_data2.argument.flags      =   [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type       = remove_file
remove_parmdbs11.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey   = parmdb
remove_parmdbs11.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                     = dppp_inplace
solve_ampphase11.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase11.control.inputkeys                = [msin,parmdb]
solve_ampphase11.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn         = DATA
solve_ampphase11.argument.msout                   = .
solve_ampphase11.argument.steps                   = [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type              = uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type           = gaincal
solve_ampphase11.argument.solvetec.caltype        = tecandphase
solve_ampphase11.argument.solvetec.parmdb         = parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn = True
solve_ampphase11.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,parmdb]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = parmdb
apply_ampphase11.argument.correct_fast1.correction            = tec
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = parmdb
apply_ampphase11.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_parmdb_map.control.kind               =  plugin
make_slow_gain_parmdb_map.control.type               =  createMapfile
make_slow_gain_parmdb_map.control.method             =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename           =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type       = remove_file
remove_parmdbs12.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey   = parmdb
remove_parmdbs12.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                      = dppp_inplace
solve_ampphase12.control.mapfiles_in               = [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase12.control.inputkeys                 = [msin,parmdb]
solve_ampphase12.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase12.argument.msout                    = .
solve_ampphase12.argument.steps                    = [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type               = uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type           = gaincal
solve_ampphase12.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb         = parmdb
solve_ampphase12.argument.solvegain.usemodelcolumn = True
solve_ampphase12.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs1.control.type       = merge_parmdbs_in_time
merge_amp_parmdbs1.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs1.control.inputkey   = mslist
merge_amp_parmdbs1.control.outputkey  = outparmdb
merge_amp_parmdbs1.argument.flags     = [mslist,instrument_slow,outparmdb]

# smooth the amplitues in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp1.control.type       = {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in = merge_amp_parmdbs1.output.mapfile
smooth_amp1.control.inputkey   = ampparmdb
smooth_amp1.control.outputkey  = outparmdb
smooth_amp1.control.arguments  = [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_parmdb_map.control.kind             = plugin
expand_smoothed_amp1_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_in       = smooth_amp1.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp1_parmdb_map.control.filename         = expand_amp1_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                 = dppp
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_amp1.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp1.argument.msout.overwrite                     = True
apply_amp1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp1.argument.steps                               = [correct_slow,avg]
apply_amp1.argument.correct_slow.type                   = applycal
apply_amp1.argument.correct_slow.parmdb                 = parmdb
apply_amp1.argument.correct_slow.invert                 = True
apply_amp1.argument.avg.type                            = squash
apply_amp1.argument.avg.freqstep                        = 1
apply_amp1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                = "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate    = 16
apply_amp1.argument.msout.storagemanager.weightbitrate  = 12
apply_amp1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation = 1.5
apply_amp1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind        = plugin
create_compressed_mapfile3.control.type        = compressMapfile
create_compressed_mapfile3.control.mapfile_in  = apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile3.control.filename    = image3_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image31.control.type                    = wsclean
wsclean_image31.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image31.control.inputkeys               = [msfile,fitsmask]
wsclean_image31.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image31.argument.fitsmask               = fitsmask
wsclean_image31.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image31.argument.niter                  = 1000
wsclean_image31.argument.threshold              = 0.0
wsclean_image31.argument.pol                    = I
wsclean_image31.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image31.argument.mgain                  = 0.6
wsclean_image31.argument.cleanborder            = 0
wsclean_image31.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image31.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image31.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image31.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image31.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image31.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image31.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels = 3
wsclean_image21.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image31.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image31.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map31.control.kind        = plugin
create_imagebase_map31.control.type        = trimMapfile
create_imagebase_map31.control.mapfile_in  = wsclean_image31.output.wsclean_image31-image.fits.mapfile
create_imagebase_map31.control.trim        = -
create_imagebase_map31.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map31.control.filename    = wsclean_image31_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile31.control.kind        = plugin
adjust_wsclean_mapfile31.control.type        = appendMapfile
adjust_wsclean_mapfile31.control.mapfile_in  = create_imagebase_map31.output.mapfile
adjust_wsclean_mapfile31.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile31.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile31.control.filename    = wsclean_image31_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask3.control.type                    = make_clean_mask
mask3.control.mapfile_in              = adjust_wsclean_mapfile31.output.mapfile
mask3.control.inputkey                = imagefile
mask3.control.outputkey               = maskfile
mask3.argument.flags                  = [imagefile,maskfile]
mask3.argument.region_file            = {{ region_selfcal }}
mask3.argument.threshpix              = 10
mask3.argument.threshisl              = 10
mask3.argument.iterate_threshold      = True
mask3.argument.atrous_do              = {{ atrous_do }}
mask3.argument.rmsbox                 = (80,20)
mask3.argument.adaptive_rmsbox        = True
mask3.argument.trim_by                = 0.4
mask3.argument.img_format             = fits
mask3.argument.adaptive_thresh        = 180
mask3.argument.threshold_format       = float
mask3.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image32.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile,mask3.output.threshold_5sig.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image32.argument.threshold              = threshold
wsclean_image32.argument.niter                  = 10000
{% else %}
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask]
wsclean_image32.argument.threshold              = 0.0
wsclean_image32.argument.niter                  = 1000
{% endif %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image32.argument.fitsmask               = fitsmask
wsclean_image32.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.pol                    = I
wsclean_image32.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                  = 0.6
wsclean_image32.argument.cleanborder            = 0
wsclean_image32.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image32.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
wsclean_image32.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.tempdir                = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image32.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image32.argument.deconvolution-channels = 3
wsclean_image32.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image32.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

########## start of selfcal loop

# loop step
loop_ampcal.control.kind      = loop
loop_ampcal.control.type      = conditional
loop_ampcal.control.loopcount = {{ loopcount }}
loop_ampcal.control.loopsteps = [create_imagebase_map32,create_expanded_model3_mapfile,pad_selfcal_model3_images,wsclean_ft3,{% if pre_average %}copy_model_data3,{% endif %}remove_parmdbs21,solve_ampphase21,apply_ampphase21,merge_phase_parmdbs,remove_parmdbs22,solve_ampphase22,merge_amp_parmdbs2,smooth_amp2,expand_smoothed_amp2_parmdb_map,apply_amp2,create_compressed_mapfile4,wsclean_image41,create_imagebase_map41,adjust_wsclean_mapfile41,mask4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image,check_image]

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map32.control.kind        = plugin
create_imagebase_map32.control.type        = trimMapfile
create_imagebase_map32.control.mapfile_in  = wsclean_image32.output.wsclean_image32-image.fits.mapfile
create_imagebase_map32.control.trim        = -
create_imagebase_map32.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map32.control.filename    = model3_rootnames.mapfile
create_imagebase_map32.control.counter     = loop_ampcal.output.counter

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model3_mapfile.control.kind             = plugin
create_expanded_model3_mapfile.control.type             = expandMapfile
create_expanded_model3_mapfile.control.mapfile_in       = create_imagebase_map32.output.mapfile
create_expanded_model3_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model3_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model3_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model3_images.control.type       = pad_image
pad_selfcal_model3_images.control.mapfile_in = create_imagebase_map32.output.mapfile
pad_selfcal_model3_images.control.inputkey   = imagefile
pad_selfcal_model3_images.argument.flags     = [imagefile]

# predict model visibilities, length =  times
wsclean_ft3.control.type         = wsclean_ft
wsclean_ft3.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model3_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft3.control.inputkeys    = [msfile,name,size]
wsclean_ft3.argument.flags       = [-predict,msfile]
wsclean_ft3.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft3.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft3.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft3.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft3.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data3.control.type        =   copy_column
copy_model_data3.control.mapfiles_in =   [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data3.control.inputkeys   =   [ms_from,ms_to]
copy_model_data3.argument.flags      =   [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs21.control.type       = remove_file
remove_parmdbs21.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs21.control.inputkey   = parmdb
remove_parmdbs21.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase21.control.type                     = dppp_inplace
solve_ampphase21.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase21.control.inputkeys                = [msin,parmdb]
solve_ampphase21.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn         = DATA
solve_ampphase21.argument.msout                   = .
solve_ampphase21.argument.steps                   = [uvcut,solvetec]
solve_ampphase21.argument.uvcut.type              = uvwflagger
solve_ampphase21.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type           = gaincal
solve_ampphase21.argument.solvetec.caltype        = tecandphase
solve_ampphase21.argument.solvetec.parmdb         = parmdb
solve_ampphase21.argument.solvetec.usemodelcolumn = True
solve_ampphase21.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 = dppp_inplace
apply_ampphase21.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase21.control.inputkeys                            = [msin,parmdb]
apply_ampphase21.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     = DATA
apply_ampphase21.argument.msout                               = .
apply_ampphase21.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase21.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type                  = applycal
apply_ampphase21.argument.correct_fast1.parmdb                = parmdb
apply_ampphase21.argument.correct_fast1.correction            = tec
apply_ampphase21.argument.correct_fast1.invert                = True
apply_ampphase21.argument.correct_fast2.type                  = applycal
apply_ampphase21.argument.correct_fast2.parmdb                = parmdb
apply_ampphase21.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase21.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                = "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    = 16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase21.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase21.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_parmdbs.control.type       = merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey   = mslist
merge_phase_parmdbs.control.outputkey  = outparmdb
merge_phase_parmdbs.argument.flags     = [mslist,instrument,outparmdb]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs22.control.type       = remove_file
remove_parmdbs22.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs22.control.inputkey   = parmdb
remove_parmdbs22.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase22.control.type                      = dppp_inplace
solve_ampphase22.control.mapfiles_in               = [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase22.control.inputkeys                 = [msin,parmdb]
solve_ampphase22.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase22.argument.msout                    = .
solve_ampphase22.argument.steps                    = [uvcut,solvegain]
solve_ampphase22.argument.uvcut.type               = uvwflagger
solve_ampphase22.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.type           = gaincal
solve_ampphase22.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase22.argument.solvegain.parmdb         = parmdb
solve_ampphase22.argument.solvegain.usemodelcolumn = True
solve_ampphase22.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
merge_amp_parmdbs2.control.type       = merge_parmdbs_in_time
merge_amp_parmdbs2.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs2.control.inputkey   = mslist
merge_amp_parmdbs2.control.outputkey  = outparmdb
merge_amp_parmdbs2.argument.flags     = [mslist,instrument_slow,outparmdb]

# smooth the amplitudes in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp2.control.type       = {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in = merge_amp_parmdbs2.output.mapfile
smooth_amp2.control.inputkey   = ampparmdb
smooth_amp2.control.outputkey  = outparmdb
smooth_amp2.control.arguments  = [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_parmdb_map.control.kind             = plugin
expand_smoothed_amp2_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_in       = smooth_amp2.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp2_parmdb_map.control.filename         = expand_amp2_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                 = dppp
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_amp2.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp2.argument.msout.overwrite                     = True
apply_amp2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp2.argument.steps                               = [correct_slow,avg]
apply_amp2.argument.correct_slow.type                   = applycal
apply_amp2.argument.correct_slow.parmdb                 = parmdb
apply_amp2.argument.correct_slow.invert                 = True
apply_amp2.argument.avg.type                            = squash
apply_amp2.argument.avg.freqstep                        = 1
apply_amp2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                = "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate    = 16
apply_amp2.argument.msout.storagemanager.weightbitrate  = 12
apply_amp2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation = 1.5
apply_amp2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind        = plugin
create_compressed_mapfile4.control.type        = compressMapfile
create_compressed_mapfile4.control.mapfile_in  = apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile4.control.filename    = image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image41.control.type                     = wsclean
wsclean_image41.control.mapfiles_in              = [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image41.control.inputkeys                = [msfile,fitsmask]
wsclean_image41.argument.flags                   = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image41.argument.fitsmask                = fitsmask
wsclean_image41.argument.size                    = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image41.argument.niter                   = 1000
wsclean_image41.argument.threshold               = 0.0
wsclean_image41.argument.pol                     = I
wsclean_image41.argument.weight                  = briggs {{ robust_selfcal }}
wsclean_image41.argument.mgain                   = 0.6
wsclean_image41.argument.cleanborder             = 0
wsclean_image41.argument.minuv-l                 = {{ selfcal_min_uv_lambda }}
wsclean_image41.argument.scale                   = {{ cellsize_selfcal_deg }}
wsclean_image41.argument.channelsout             = {{ wsclean_nchannels_selfcal }}
wsclean_image41.argument.mem                     = {{ max_percent_memory_per_proc_single }}
wsclean_image41.argument.j                       = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image41.argument.tempdir                 = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image41.argument.multiscale-scales       = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image41.argument.deconvolution-channels  = 3
wsclean_image41.argument.fit-spectral-pol        = 3
{% endif %}
wsclean_image41.argument.weighting-rank-filter   = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image41.argument.baseline-averaging      = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map41.control.kind        = plugin
create_imagebase_map41.control.type        = trimMapfile
create_imagebase_map41.control.mapfile_in  = wsclean_image41.output.wsclean_image41-image.fits.mapfile
create_imagebase_map41.control.trim        = -
create_imagebase_map41.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map41.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile41.control.kind        = plugin
adjust_wsclean_mapfile41.control.type        = appendMapfile
adjust_wsclean_mapfile41.control.mapfile_in  = create_imagebase_map41.output.mapfile
adjust_wsclean_mapfile41.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile41.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile41.control.filename    = wsclean_image41_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask4.control.type                    = make_clean_mask
mask4.control.mapfile_in              = adjust_wsclean_mapfile41.output.mapfile
mask4.control.inputkey                = imagefile
mask4.control.outputkey               = maskfile
mask4.argument.flags                  = [imagefile,maskfile]
mask4.argument.region_file            = {{ region_selfcal }}
mask4.argument.threshpix              = 8
mask4.argument.threshisl              = 8
mask4.argument.iterate_threshold      = True
mask4.argument.atrous_do              = {{ atrous_do }}
mask4.argument.rmsbox                 = (80,20)
mask4.argument.adaptive_rmsbox        = True
mask4.argument.trim_by                = 0.4
mask4.argument.img_format             = fits
mask4.argument.adaptive_thresh        = 200
mask4.argument.threshold_format       = float
mask4.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image42.control.type                     = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image42.control.mapfiles_in              = [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile,mask4.output.threshold_5sig.mapfile]
wsclean_image42.control.inputkeys                = [msfile,fitsmask,threshold]
wsclean_image42.argument.threshold               = threshold
wsclean_image42.argument.niter                   = 10000
{% else %}
wsclean_image42.control.mapfiles_in              = [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile]
wsclean_image42.control.inputkeys                = [msfile,fitsmask]
wsclean_image42.argument.threshold               = 0.0
wsclean_image42.argument.niter                   = 1000
{% endif %}
wsclean_image42.argument.flags                   = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image42.argument.fitsmask                = fitsmask
wsclean_image42.argument.size                    = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.pol                     = I
wsclean_image42.argument.weight                  = briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                   = 0.6
wsclean_image42.argument.cleanborder             = 0
wsclean_image42.argument.minuv-l                 = {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                   = {{ cellsize_selfcal_deg }}
wsclean_image42.argument.channelsout             = {{ wsclean_nchannels_selfcal }}
wsclean_image42.argument.mem                     = {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                       = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.tempdir                 = {{ local_dir_parent }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image42.argument.multiscale-scales       = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image42.argument.deconvolution-channels  = 3
wsclean_image42.argument.fit-spectral-pol        = 3
{% endif %}
wsclean_image42.argument.weighting-rank-filter   = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging      = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind        = plugin
create_imagebase_map42.control.type        = trimMapfile
create_imagebase_map42.control.mapfile_in  = wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim        = -
create_imagebase_map42.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map42.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind        = plugin
adjust_wsclean_mapfile42.control.type        = appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in  = create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename    = compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image.control.type       = copy_image
copy_image.control.mapfile_in = adjust_wsclean_mapfile42.output.mapfile
copy_image.control.inputkey   = image
copy_image.argument.flags     = [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image.control.type        = compare_image_stats
check_image.control.mapfiles_in = [adjust_wsclean_mapfile42.output.mapfile,copy_image.output.previous_image.mapfile]
check_image.control.inputkeys   = [image_new,image_prev]
check_image.argument.flags      = [image_new,image_prev]

########## end of selfcal loop
{% endblock selfcal_parameters %}

{% if selfcal_local_dir is not none %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type       = remove_synced_data
remove_concat_data.control.mapfile_in = make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey   = msfile
remove_concat_data.argument.flags     = [msfile]
{% endif %}

# merge the phase and amplitude parmDBs, length = 1
merge_selfcal_parmdbs.control.type        = merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in = [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys   = [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey   = parmdb_out
merge_selfcal_parmdbs.argument.flags      = [parmdb_p,parmdb_a,parmdb_out]

{% if create_preapply_parmdb %}
# make a phase-only parmDB suitable for preapplication, length = 1
create_preapply_parmdb.control.type       = reset_amps
create_preapply_parmdb.control.mapfile_in = merge_selfcal_parmdbs.output.mapfile
create_preapply_parmdb.control.inputkey   = inparmdb
create_preapply_parmdb.control.outputkey  = outparmdb
create_preapply_parmdb.control.arguments  = [inparmdb,outparmdb]
{% endif %}

# convert the merged the phase and amplitude parmDBs to gain parmDBs, length = 1
# if phases are pre-applied, then also add them in
convert_merged_selfcal_parmdbs.control.type        = convert_solutions_to_gain
{% if preapply_phase_cal %}
convert_merged_selfcal_parmdbs.control.mapfiles_in = [merge_selfcal_parmdbs.output.mapfile,{{ preapply_parmdb_mapfile }}]
convert_merged_selfcal_parmdbs.control.inputkeys   = [parmdb_in,parmdb_pre]
convert_merged_selfcal_parmdbs.control.outputkey   = parmdb_out
convert_merged_selfcal_parmdbs.argument.flags      = [parmdb_in,parmdb_out,parmdb_pre]
{% else %}
convert_merged_selfcal_parmdbs.control.mapfile_in  = merge_selfcal_parmdbs.output.mapfile
convert_merged_selfcal_parmdbs.control.inputkey    = parmdb_in
convert_merged_selfcal_parmdbs.control.outputkey   = parmdb_out
convert_merged_selfcal_parmdbs.argument.flags      = [parmdb_in,parmdb_out]
{% endif %}

# make plots of the selfcal solutions from the marged parmDB, length = 1
make_selfcal_plots.control.type       = make_selfcal_plots
make_selfcal_plots.control.mapfile_in = merge_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys  = parmdb
make_selfcal_plots.control.outputkey  = plots_root
make_selfcal_plots.argument.flags     = [parmdb,plots_root]
make_selfcal_plots.argument.fourpol   = {{ fourpol }}

# create a mapfile with the selfcal images, length = 1
create_selfcal_images_mapfile.control.kind        = plugin
create_selfcal_images_mapfile.control.type        = addSelfcalImagesMapfile
create_selfcal_images_mapfile.control.selfcal_dir = {{ pipeline_parset_dir }}
create_selfcal_images_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_selfcal_images_mapfile.control.hosts       = {{ hosts }}
create_selfcal_images_mapfile.control.filename    = selfcal_images.mapfile

# make plots of the selfcal images, length = 1
make_selfcal_images.control.type       = make_selfcal_images
make_selfcal_images.control.mapfile_in = create_selfcal_images_mapfile.output.mapfile
make_selfcal_images.control.inputkeys  = imagefiles
make_selfcal_images.argument.flags     = [imagefiles]

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind             = plugin
expand_merged_parmdb_map.control.type             = expandMapfile
expand_merged_parmdb_map.control.mapfile_in       = convert_merged_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_merged_parmdb_map.control.filename         = expand_merged_parmdbs.mapfile

# create a mapfile for the last calibrator model image, length = 1
create_model4_map.control.kind        = plugin
create_model4_map.control.type        = trimMapfile
create_model4_map.control.mapfile_in  = wsclean_image42.output.wsclean_image42-model.fits.mapfile
create_model4_map.control.trim        = -
create_model4_map.control.mapfile_dir = input.output.mapfile_dir
create_model4_map.control.filename    = final_model_rootnames.mapfile

# Blank (with zeros) regions of the model image that lie outside of the patch region, length = 1
blank_model.control.type                    = blank_image
blank_model.control.mapfile_in              = create_model4_map.output.mapfile
blank_model.control.inputkey                = infile
blank_model.control.outputkey               = outfile
blank_model.argument.flags                  = [infile,{{ vertices_file }},outfile]
blank_model.argument.blank_value            = zero
blank_model.argument.img_format             = fits
blank_model.argument.image_is_wsclean_model = True

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_blank_model_map.control.kind             = plugin
expand_blank_model_map.control.type             = expandMapfile
expand_blank_model_map.control.mapfile_in       = blank_model.output.mapfile
expand_blank_model_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_blank_model_map.control.mapfile_dir      = input.output.mapfile_dir
expand_blank_model_map.control.filename         = expand_blank_model_map.mapfile

# make the new calibrator sky model, len = nbands
make_new_cal_skymodel.control.type        = fits2sky
make_new_cal_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_blank_model_map.output.mapfile]
make_new_cal_skymodel.control.inputkeys   = [msfile,rootname]
make_new_cal_skymodel.control.outputkey   = skymodel
make_new_cal_skymodel.argument.flags      = [rootname,msfile,skymodel]

{% if not is_patch %}

# extract the skymodel for the full facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type       = make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey   = fullmodelfile
make_facet_skymodels_all.control.outputkey  = outfile
make_facet_skymodels_all.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type       = make_sourcedb
make_sourcedb_all_facet_sources.control.mapfile_in = make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.inputkey   = in
make_sourcedb_all_facet_sources.argument.format    = <
make_sourcedb_all_facet_sources.argument.outtype   = blob

# expand the dir-indep sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           = plugin
expand_sourcedb_all_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     = make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       = expand_sourcedb_all_facet_sources.mapfile

{% if use_wideband %}
# select 6 bands spread over the full bandwidth for imaging, length = 6 * nchunks
select_imaging_bands.control.kind        = plugin
select_imaging_bands.control.type        = selectDistFreqs
select_imaging_bands.control.mapfile_in  = create_ms_map.output.mapfile
select_imaging_bands.control.mapfile_dir = input.output.mapfile_dir
select_imaging_bands.control.filename    = imaging_bands.mapfile

# adjust the dir-indep sourcedb mapfile to match the selected bands, length = 6 * nchunks
select_sourcedb_all_facet_sources.control.kind         = plugin
select_sourcedb_all_facet_sources.control.type         = matchDistFreqs
select_sourcedb_all_facet_sources.control.mapfile_in   = expand_sourcedb_all_facet_sources.output.mapfile
select_sourcedb_all_facet_sources.control.mapfile_dist = select_imaging_bands.output.mapfile
select_sourcedb_all_facet_sources.control.mapfile_full = create_ms_map.output.mapfile
select_sourcedb_all_facet_sources.control.mapfile_dir  = input.output.mapfile_dir
select_sourcedb_all_facet_sources.control.filename     = imaging_sourcedbs.mapfile

# adjust the dir-indep parmdb mapfile to match the selected bands, length = 6 * nchunks
select_parmdb_map.control.kind         = plugin
select_parmdb_map.control.type         = matchDistFreqs
select_parmdb_map.control.mapfile_in   = create_parmdb_map.output.mapfile
select_parmdb_map.control.mapfile_dist = select_imaging_bands.output.mapfile
select_parmdb_map.control.mapfile_full = create_ms_map.output.mapfile
select_parmdb_map.control.mapfile_dir  = input.output.mapfile_dir
select_parmdb_map.control.filename     = imaging_parmdbs.mapfile

# adjust the dir-dep parmdb mapfile to match the selected bands, length = 6 * nchunks
select_merged_parmdb_map.control.kind             = plugin
select_merged_parmdb_map.control.type             = expandMapfile
select_merged_parmdb_map.control.mapfile_in       = convert_merged_selfcal_parmdbs.output.mapfile
select_merged_parmdb_map.control.mapfile_to_match = select_imaging_bands.output.mapfile
select_merged_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
select_merged_parmdb_map.control.filename         = select_merged_parmdbs.mapfile
{% endif %}

# shift the empty data, add all facet sources, apply the direction-dependent solutions and average, length = nfiles or 6 * nchunks
# compress data and weights
apply_dir_dep.control.type                                   = dppp
{% if use_wideband %}
apply_dir_dep.control.mapfiles_in                            = [select_imaging_bands.output.mapfile,select_sourcedb_all_facet_sources.output.mapfile,select_parmdb_map.output.mapfile,select_merged_parmdb_map.output.mapfile]
{% else %}
apply_dir_dep.control.mapfiles_in                            = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile,expand_merged_parmdb_map.output.mapfile]
{% endif %}
apply_dir_dep.control.inputkeys                              = [msin,sourcedb,dir_indep_parmdb,dir_dep_parmdb]
apply_dir_dep.argument.numthreads                            = {{ max_cpus_per_io_proc_nfiles }}
apply_dir_dep.argument.msin.datacolumn                       = {{ subtracted_data_colname }}
apply_dir_dep.argument.msout.overwrite                       = True
apply_dir_dep.argument.msout.writefullresflag                = False
{% if local_dir is not none %}
apply_dir_dep.argument.local_scratch_dir                     = {{ local_dir }}
{% endif %}
apply_dir_dep.argument.steps                                 = [shift,add,correct,flagzero,avg]
apply_dir_dep.argument.shift.type                            = phaseshifter
apply_dir_dep.argument.shift.phasecenter                     = [{{ facet_ra }}deg, {{ facet_dec }}deg]
apply_dir_dep.argument.add.type                              = predict
apply_dir_dep.argument.add.sourcedb                          = sourcedb
apply_dir_dep.argument.add.operation                         = add
apply_dir_dep.argument.add.applycal.parmdb                   = dir_indep_parmdb
apply_dir_dep.argument.correct.type                          = applycal
apply_dir_dep.argument.correct.parmdb                        = dir_dep_parmdb
apply_dir_dep.argument.correct.invert                        = True
apply_dir_dep.argument.flagzero.type                         = preflagger
apply_dir_dep.argument.flagzero.amplmin                      = 1e-20
apply_dir_dep.argument.avg.type                              = squash
apply_dir_dep.argument.avg.freqstep                          = {{ facetimage_freqstep }}
apply_dir_dep.argument.avg.timestep                          = {{ facetimage_timestep }}
# Don't compress for now, as WSClean tries to allocate too much memory
# {% if use_compression %}
# apply_dir_dep.argument.msout.storagemanager                = "Dysco"
# apply_dir_dep.argument.msout.storagemanager.databitrate    = 16
# apply_dir_dep.argument.msout.storagemanager.weightbitrate  = 12
# apply_dir_dep.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
# apply_dir_dep.argument.msout.storagemanager.disttruncation = 1.5
# apply_dir_dep.argument.msout.storagemanager.normalization  = "AF"
# {% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind        = plugin
create_compressed_mapfile5.control.type        = compressMapfile
create_compressed_mapfile5.control.mapfile_in  = apply_dir_dep.output.mapfile
create_compressed_mapfile5.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile5.control.filename    = concat_averaged_input.mapfile

# make a mask from the last selfcal image, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_imagebase_map42.output.mapfile
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [create_compressed_mapfile5.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
wsclean_image_full.argument.flags                 = [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = 2000
wsclean_image_full.argument.threshold             = {{ wsclean_full1_image_threshold_jy }}
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_selfcal }}
wsclean_image_full.argument.mgain                 = 0.6
wsclean_image_full.argument.cleanborder           = 0
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_selfcal_deg }}
{% if use_wideband %}
wsclean_image_full.argument.channelsout           = 6
{% else %}
wsclean_image_full.argument.channelsout           = 1
{% endif %}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full.argument.weighting-rank-filter = 3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind        = plugin
adjust_wsclean_mapfile1.control.type        = appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in  = create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename    = final_image1.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask5.control.type                = make_clean_mask
mask5.control.mapfile_in          = adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey            = imagefile
mask5.control.outputkey           = maskfile
mask5.argument.flags              = [imagefile,maskfile]
mask5.argument.region_file        = {{ region_field }}
mask5.argument.threshisl          = 10
mask5.argument.threshpix          = 20
mask5.argument.rmsbox             = (80,20)
mask5.argument.adaptive_rmsbox    = True
mask5.argument.atrous_do          = False
mask5.argument.img_format         = fits
mask5.argument.vertices_file      = {{ vertices_file }}
mask5.argument.exclude_cal_region = True

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model5_map.control.kind        = plugin
create_model5_map.control.type        = trimMapfile
create_model5_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-model.fits.mapfile
create_model5_map.control.trim        = -
create_model5_map.control.mapfile_dir = input.output.mapfile_dir
create_model5_map.control.filename    = final_model_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile2.control.kind        = plugin
adjust_wsclean_mapfile2.control.type        = appendMapfile
adjust_wsclean_mapfile2.control.mapfile_in  = create_model5_map.output.mapfile
adjust_wsclean_mapfile2.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile2.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile2.control.filename    = final_image.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model5_map.control.kind             = plugin
expand_model5_map.control.type             = expandMapfile
expand_model5_map.control.mapfile_in       = create_model5_map.output.mapfile
expand_model5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model5_map.control.filename         = expand_model5_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask5_map.control.kind             = plugin
expand_mask5_map.control.type             = expandMapfile
expand_mask5_map.control.mapfile_in       = mask5.output.mapfile
expand_mask5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask5_map.control.filename         = expand_mask5_map.mapfile

# make full-facet sky model, using mask above, len = nbands
make_new_facet_skymodel.control.type        = fits2sky
make_new_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model5_map.output.mapfile,expand_mask5_map.output.mapfile]
make_new_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_new_facet_skymodel.control.outputkey   = skymodel
make_new_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

# extract the old sky model for this facet minus the calibrator from global skymodel, length = nbands
# this is done to pick up any extended emission missed in the full facet model
make_old_facet_skymodels_minus_cal.control.type        = make_facet_skymodel
make_old_facet_skymodels_minus_cal.control.mapfile_in  = create_full_skymodels_map.output.mapfile
make_old_facet_skymodels_minus_cal.control.inputkey    = fullmodelfile
make_old_facet_skymodels_minus_cal.control.outputkey   = outfile
make_old_facet_skymodels_minus_cal.argument.flags      = [fullmodelfile,outfile,{{ vertices_file }}]
make_old_facet_skymodels_minus_cal.argument.remove_cal = True

# combine the new calibrator and facet sky models with the old one, length = nbands
combine_skymodels.control.type        = combine_skymodels
combine_skymodels.control.mapfiles_in = [make_old_facet_skymodels_minus_cal.output.mapfile,make_new_facet_skymodel.output.mapfile,make_new_cal_skymodel.output.mapfile]
combine_skymodels.control.inputkeys   = [oldfacetmodel,newfacetmodel,calmodel]
combine_skymodels.control.outputkey   = skymodel
combine_skymodels.argument.flags      = [calmodel,newfacetmodel,skymodel,oldfacetmodel]

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = combine_skymodels.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% else %}
# for patches, just make a sourcedb from the new calibrator sky model

# convert the calibrator sky model (= facet sky model) into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = make_new_cal_skymodel.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" block

# predict the old and new models and subtract the old one from the new one, length = nfiles
# compress weights only
predict_and_difference_models.control.type                                 = dppp
{% if not is_patch %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,dir_dep_sourcedb,dir_dep_parmdb,dir_indep_sourcedb,dir_indep_parmdb]
{% else %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,dir_dep_sourcedb,dir_dep_parmdb,dir_indep_sourcedb,dir_indep_parmdb]
{% endif %}
predict_and_difference_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
predict_and_difference_models.argument.msin.datacolumn                     = DATA
predict_and_difference_models.argument.msout.overwrite                     = True
predict_and_difference_models.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
predict_and_difference_models.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
predict_and_difference_models.argument.steps                               = [pred_new,subtract_old]
predict_and_difference_models.argument.pred_new.type                       = predict
predict_and_difference_models.argument.pred_new.sourcedb                   = dir_dep_sourcedb
predict_and_difference_models.argument.pred_new.applycal.parmdb            = dir_dep_parmdb
predict_and_difference_models.argument.pred_new.operation                  = replace
predict_and_difference_models.argument.subtract_old.type                   = predict
predict_and_difference_models.argument.subtract_old.sourcedb               = dir_indep_sourcedb
predict_and_difference_models.argument.subtract_old.applycal.parmdb        = dir_indep_parmdb
predict_and_difference_models.argument.subtract_old.operation              = subtract
{% if use_compression %}
predict_and_difference_models.argument.msout.storagemanager                = "Dysco"
predict_and_difference_models.argument.msout.storagemanager.databitrate    = 0
predict_and_difference_models.argument.msout.storagemanager.weightbitrate  = 12
predict_and_difference_models.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
predict_and_difference_models.argument.msout.storagemanager.disttruncation = 1.5
predict_and_difference_models.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

#
# Verify the quality of selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile1.control.kind        = plugin
create_middle_band_mapfile1.control.type        = selectMiddleFreq
create_middle_band_mapfile1.control.mapfile_in  = create_ms_map.output.mapfile
create_middle_band_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile1.control.filename    = single_band_orig.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile2.control.kind        = plugin
create_middle_band_mapfile2.control.type        = selectMiddleFreq
create_middle_band_mapfile2.control.mapfile_in  = predict_and_difference_models.output.mapfile
create_middle_band_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile2.control.filename    = single_band_new.mapfile

# subtract new facet data from original data, length = ntimes
subtract_single.control.type                             = add_subtract_columns
subtract_single.control.mapfiles_in                      = [create_middle_band_mapfile2.output.mapfile,create_middle_band_mapfile1.output.mapfile]
subtract_single.control.inputkeys                        = [file1,file2]
subtract_single.argument.flags                           = [file1,file2,DATA,{{ subtracted_data_colname }},MODEL_DATA,subtract21]

# average old empty data, length = ntimes
average_pre.control.type                                 = dppp
average_pre.control.mapfile_in                           = create_middle_band_mapfile1.output.mapfile
average_pre.control.inputkey                             = msin
average_pre.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
average_pre.argument.msout.overwrite                     = True
average_pre.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_pre.argument.steps                               = [uv,avg]
average_pre.argument.uv.type                             = uvwflagger
average_pre.argument.uv.uvmmax                           = 2500.0
average_pre.argument.avg.type                            = squash
average_pre.argument.avg.freqstep                        = {{ verify_freqstep }}
average_pre.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                = "Dysco"
average_pre.argument.msout.storagemanager.databitrate    = 16
average_pre.argument.msout.storagemanager.weightbitrate  = 12
average_pre.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation = 1.5
average_pre.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                 = dppp
average_post.control.mapfile_in                           = create_middle_band_mapfile2.output.mapfile
average_post.control.inputkey                             = msin
average_post.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                     = MODEL_DATA
average_post.argument.msout.overwrite                     = True
average_post.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_post.argument.steps                               = [uv,avg]
average_post.argument.uv.type                             = uvwflagger
average_post.argument.uv.uvmmax                           = 2500.0
average_post.argument.avg.type                            = squash
average_post.argument.avg.freqstep                        = {{ verify_freqstep }}
average_post.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                = "Dysco"
average_post.argument.msout.storagemanager.databitrate    = 16
average_post.argument.msout.storagemanager.weightbitrate  = 12
average_post.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation = 1.5
average_post.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind        = plugin
average_pre_compressed_map.control.type        = compressMapfile
average_pre_compressed_map.control.mapfile_in  = average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_pre_compressed_map.control.filename    = average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type         = wsclean
wsclean_pre.control.mapfile_in   = average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey     = msfiles
wsclean_pre.argument.flags       = [-no-update-model-required,msfiles]
wsclean_pre.argument.size        = 2048 2048
wsclean_pre.argument.niter       = 10
wsclean_pre.argument.threshold   = 0.0
wsclean_pre.argument.pol         = I
wsclean_pre.argument.weight      = briggs -0.5
wsclean_pre.argument.mgain       = 0.5
wsclean_pre.argument.gain        = 0.1
wsclean_pre.argument.cleanborder = 0
wsclean_pre.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l     = 2500
wsclean_pre.argument.scale       = 0.00833
wsclean_pre.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind        = plugin
average_post_compressed_map.control.type        = compressMapfile
average_post_compressed_map.control.mapfile_in  = average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_post_compressed_map.control.filename    = average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type         = wsclean
wsclean_post.control.mapfile_in   = average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey     = msfiles
wsclean_post.argument.flags       = [-no-update-model-required,msfiles]
wsclean_post.argument.size        = 2048 2048
wsclean_post.argument.niter       = 10
wsclean_post.argument.threshold   = 0.0
wsclean_post.argument.pol         = I
wsclean_post.argument.weight      = briggs -0.5
wsclean_post.argument.mgain       = 0.5
wsclean_post.argument.gain        = 0.1
wsclean_post.argument.cleanborder = 0
wsclean_post.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l     = 2500
wsclean_post.argument.scale       = 0.00833
wsclean_post.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type        = verify_subtract
verify_subtract.control.mapfiles_in = [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys   = [image_pre,image_post]
verify_subtract.argument.flags      = [image_pre,image_post,0.75]
