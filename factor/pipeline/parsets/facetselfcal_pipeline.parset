pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_full_skymodels_map, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, {% if preapply_phase_cal %} expand_preapply_h5parm_map, {% endif %} shift_cal, {% if preapply_phase_cal %} shift_cal_dir_indep, {% endif %} create_compressed_mapfile_data, sort_into_Groups, sort_into_Groups_maps, concat_data, {% if pre_average %} regroup_shift_cal, calc_bl, create_bl_mapfile1, pre_average, make_blavg_data_mapfile, concat_blavg_data, create_bl_mapfile2, pre_average_freq, {% endif %} {% if selfcal_local_dir is not none %} {% if not pre_average %} make_concat_data_sync_mapfile, adjust_concat_data_hosts, sync_concat_data_to_local, {% else %} make_concat_blavg_data_sync_mapfile, adjust_concat_blavg_data_hosts, adjust_concat_data_hosts, sync_concat_blavg_data_to_local, {% endif %} {% endif %} concat_data_compressed_mapfile, {% block selfcal_steps %} {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image01, create_imagebase_map01, adjust_wsclean_mapfile01, mask0, wsclean_image02, regroup_concat_data_map, make_fast_phase_h5parm_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% else %} group_skymodel0, make_sourcedb0, expand_sourcedb0_map, {% endif %} remove_h5parms1, solve_phaseonly1, {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image12, group_skymodel1, make_sourcedb1, expand_sourcedb1_map, remove_h5parms2, solve_phaseonly2, apply_phaseonly2, create_compressed_mapfile2, wsclean_image22, group_skymodel2, make_sourcedb2, expand_sourcedb2_map, remove_h5parms11, solve_ampphase11, apply_ampphase11, make_slow_gain_h5parm_map, remove_h5parms12, solve_ampphase12, create_compressed_mapfile_slow, create_combined_slow_output_map, match_host_slow, combine_slow_gains1, smooth_amp1, expand_smoothed_amp1_h5parm_map, apply_amp1, create_compressed_mapfile3, wsclean_image32, loop_ampcal, {% endblock selfcal_steps %} {% if selfcal_local_dir is not none %} {% if not pre_average %} remove_concat_data, {% else %} remove_concat_blavg_data, {% endif %} {% endif %} create_combined_output_map, combine_h5parms, expand_combined_h5parm, make_selfcal_plots, create_selfcal_images_mapfile, make_selfcal_images, create_model4_map, expand_model4_map, blank_mask, expand_mask4_map, make_new_cal_skymodel, {% if not is_patch or mscale_selfcal_do %} make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, prepare_imaging_data, {% if not is_patch %} create_compressed_mapfile5, premask, wsclean_image_full, create_imagebase_map, adjust_wsclean_mapfile1, mask5, check_mask_high, create_model5_map, expand_model5_map, expand_mask5_map, make_high_facet_skymodel, combine_skymodels_high, {% endif %} make_sourcedb_high, expand_sourcedb_high, subtract_high, create_compressed_mapfile6, premask_med, wsclean_image_full_med, create_imagebase_med_map, adjust_wsclean_mapfile3, mask6, check_mask_med, expand_model6_map, expand_mask6_map, make_med_facet_skymodel, combine_facet_skymodels, make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% else %} make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% endif %} predict_and_difference_models, create_middle_band_mapfile1, create_middle_band_mapfile2, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind        = plugin
create_full_skymodels_map.control.type        = addListMapfile
create_full_skymodels_map.control.hosts       = {{ hosts }}
create_full_skymodels_map.control.files       = {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir = input.output.mapfile_dir
create_full_skymodels_map.control.filename    = full_skymodels.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type       = make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey   = fullmodelfile
make_facet_skymodels_cal.control.outputkey  = outfile
make_facet_skymodels_cal.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only  = True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type       = make_sourcedb
make_sourcedb_cal_facet_sources.control.mapfile_in = make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.inputkey   = in
make_sourcedb_cal_facet_sources.argument.format    = <
make_sourcedb_cal_facet_sources.argument.outtype   = blob
make_sourcedb_cal_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind           = plugin
expand_sourcedb_cal_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in     = make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename       = expand_sourcedb_cal_facet_sources.mapfile

{% if preapply_phase_cal %}
# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_preapply_h5parm_map.control.kind             = plugin
expand_preapply_h5parm_map.control.type             = expandMapfile
expand_preapply_h5parm_map.control.mapfile_in       = {{ preapply_h5parm_mapfile }}
expand_preapply_h5parm_map.control.mapfile_to_match = create_ms_map.output.mapfile
expand_preapply_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_preapply_h5parm_map.control.filename         = expand_preapply_h5parms.mapfile
{% endif %}

# shift data to calibrator position, predict and add calibrator sources, and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                 = dppp
{% if preapply_phase_cal %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,expand_preapply_h5parm_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,pre_h5parm]
{% else %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb]
{% endif %}
shift_cal.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                     = True
shift_cal.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,correct_prefast1,correct_prefast2,correct_preslow,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,correct_prefast1,correct_prefast2,correct_preslow,avg]
{% endif %}
shift_cal.argument.correct_prefast1.type               = applycal
shift_cal.argument.correct_prefast1.parmdb             = pre_h5parm
shift_cal.argument.correct_prefast1.correction         = tec000
shift_cal.argument.correct_prefast1.invert             = True
shift_cal.argument.correct_prefast2.type               = applycal
shift_cal.argument.correct_prefast2.parmdb             = pre_h5parm
shift_cal.argument.correct_prefast2.correction         = phase000
shift_cal.argument.correct_prefast2.invert             = True
shift_cal.argument.correct_preslow.type                = applycal
shift_cal.argument.correct_preslow.parmdb              = pre_h5parm
shift_cal.argument.correct_preslow.correction          = phase001
shift_cal.argument.correct_preslow.invert              = True
{% else %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,avg]
{% endif %}
{% endif %}
shift_cal.argument.shift.type                          = phaseshifter
shift_cal.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                            = predict
shift_cal.argument.add.sourcedb                        = sourcedb
shift_cal.argument.add.operation                       = add
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.flag.type                           = preflagger
shift_cal.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal.argument.avg.type                            = squash
shift_cal.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                        = 1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                = "Dysco"
shift_cal.argument.msout.storagemanager.databitrate    = 16
shift_cal.argument.msout.storagemanager.weightbitrate  = 12
shift_cal.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation = 1.5
shift_cal.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if preapply_phase_cal %}
# If we preapplied solutions above, we also need a dir-indep corrected   // length = nfiles
# version of the shift_cal data for the initial selfcal image
# Compress both data and weights
shift_cal_dir_indep.control.type                                 = dppp
shift_cal_dir_indep.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
shift_cal_dir_indep.control.inputkeys                            = [msin,sourcedb]
shift_cal_dir_indep.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal_dir_indep.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal_dir_indep.argument.msout.overwrite                     = True
shift_cal_dir_indep.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal_dir_indep.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal_dir_indep.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal_dir_indep.argument.steps                               = [shift,add,avg]
{% endif %}
shift_cal_dir_indep.argument.shift.type                          = phaseshifter
shift_cal_dir_indep.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal_dir_indep.argument.add.type                            = predict
shift_cal_dir_indep.argument.add.sourcedb                        = sourcedb
shift_cal_dir_indep.argument.add.operation                       = add
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal_dir_indep.argument.flag.type                           = preflagger
shift_cal_dir_indep.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal_dir_indep.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal_dir_indep.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal_dir_indep.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal_dir_indep.argument.avg.type                            = squash
shift_cal_dir_indep.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal_dir_indep.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
shift_cal_dir_indep.argument.msout.storagemanager                = "Dysco"
shift_cal_dir_indep.argument.msout.storagemanager.databitrate    = 16
shift_cal_dir_indep.argument.msout.storagemanager.weightbitrate  = 12
shift_cal_dir_indep.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal_dir_indep.argument.msout.storagemanager.disttruncation = 1.5
shift_cal_dir_indep.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_data.control.kind        = plugin
create_compressed_mapfile_data.control.type        = compressMapfile
create_compressed_mapfile_data.control.mapfile_in  = shift_cal.output.mapfile
create_compressed_mapfile_data.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_data.control.filename    = concat_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                 = sort_times_into_freqGroups
sort_into_Groups.argument.flags               = [create_compressed_mapfile_data.output.mapfile]
sort_into_Groups.argument.filename            = sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir         = input.output.mapfile_dir
sort_into_Groups.argument.hosts               = {{ hosts }}
sort_into_Groups.argument.stepname            = sort_into_Groups
sort_into_Groups.argument.enforce_numSB       = False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB               = {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad           = {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files    = True
sort_into_Groups.argument.skip_flagged_groups = False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind             = plugin
sort_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap = sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap = sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                 = dppp
concat_data.control.mapfile_out                          = sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             = msin
concat_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     = DATA
concat_data.argument.msin.missingdata                    = True
concat_data.argument.msin.orderms                        = False
concat_data.argument.msout.overwrite                     = True
concat_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_data.argument.steps                               = []
{% if use_compression %}
concat_data.argument.msout.storagemanager                = "Dysco"
concat_data.argument.msout.storagemanager.databitrate    = 16
concat_data.argument.msout.storagemanager.weightbitrate  = 12
concat_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation = 1.5
concat_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if pre_average %}
# re-group shift_cal mapfile to have one group per band, length = nbands
regroup_shift_cal.control.kind           = plugin
regroup_shift_cal.control.type           = reGroupMapfile
regroup_shift_cal.control.mapfile_in     = shift_cal.output.mapfile
regroup_shift_cal.control.mapfile_groups = create_msmulti_map.output.mapfile
regroup_shift_cal.control.mapfile_dir    = input.output.mapfile_dir
regroup_shift_cal.control.filename       = regroup_shift_cal.mapfile

# calculate baseline lengths, length = 1
calc_bl.control.type        = calculate_bl_lengths
calc_bl.control.mapfile_in  = create_compressed_mapfile_data.output.mapfile
calc_bl.control.inputkey    = datafiles
calc_bl.control.outputkey   = outfile
calc_bl.argument.flags      = [datafiles,outfile]

# expand the baseline lengths mapfile, length = nbands
create_bl_mapfile1.control.kind             = plugin
create_bl_mapfile1.control.type             = expandMapfile
create_bl_mapfile1.control.mapfile_in       = calc_bl.output.mapfile
create_bl_mapfile1.control.mapfile_to_match = regroup_shift_cal.output.mapfile
create_bl_mapfile1.control.mapfile_dir      = input.output.mapfile_dir
create_bl_mapfile1.control.filename         = expand_bl.mapfile

# do the baseline-dependent preaveraging, length = nbands
# This step makes new columns named BLAVG_DATA and BLAVG_WEIGHT_SPECTRUM
pre_average.control.type        = pre_average
pre_average.control.mapfiles_in = [regroup_shift_cal.output.mapfile,create_bl_mapfile1.output.mapfile]
pre_average.control.inputkeys   = [datafiles,blengths]
pre_average.argument.flags      = [datafiles,DATA,DATA,WEIGHT_SPECTRUM,{{ target_rms_rad }},blengths]

# make mapfile for concatenated preaveraged data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind               = plugin
make_blavg_data_mapfile.control.type               = createMapfile
make_blavg_data_mapfile.control.method             = add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in         = sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file = "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir        = input.output.mapfile_dir
make_blavg_data_mapfile.control.filename           = make_blavg_data.mapfile

# Concat the preaveraged data (and weights), length = ntimes * num_cal_blocks
# Compress both data and weights
concat_blavg_data.control.type                                 = dppp
concat_blavg_data.control.mapfile_out                          = make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                             = msin
concat_blavg_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_blavg_data.argument.msin.datacolumn                     = DATA
concat_blavg_data.argument.msin.missingdata                    = True
concat_blavg_data.argument.msin.orderms                        = False
concat_blavg_data.argument.msout.overwrite                     = True
concat_blavg_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_blavg_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_blavg_data.argument.steps                               = []
{% if use_compression %}
concat_blavg_data.argument.msout.storagemanager                = "Dysco"
concat_blavg_data.argument.msout.storagemanager.databitrate    = 16
concat_blavg_data.argument.msout.storagemanager.weightbitrate  = 12
concat_blavg_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_blavg_data.argument.msout.storagemanager.disttruncation = 1.5
concat_blavg_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# expand the baseline lengths mapfile, length = ntimes * num_cal_blocks
create_bl_mapfile2.control.kind             = plugin
create_bl_mapfile2.control.type             = expandMapfile
create_bl_mapfile2.control.mapfile_in       = calc_bl.output.mapfile
create_bl_mapfile2.control.mapfile_to_match = make_blavg_data_mapfile.output.mapfile
create_bl_mapfile2.control.mapfile_dir      = input.output.mapfile_dir
create_bl_mapfile2.control.filename         = expand_bl.mapfile

# preaverage in frequency, length = ntimes * num_cal_blocks
# this step overwrites the DATA and WEIGHT_SPECTRUM columns
pre_average_freq.control.type        = pre_average_freq
pre_average_freq.control.mapfiles_in = [concat_blavg_data.output.mapfile,create_bl_mapfile2.output.mapfile]
pre_average_freq.control.inputkeys   = [datafile,blengths]
pre_average_freq.argument.flags      = [datafile,DATA,DATA,WEIGHT_SPECTRUM,blengths,{{ cal_radius_deg }}]

{% endif %}

{% if selfcal_local_dir is not none %}
{% if not pre_average %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind            = plugin
make_concat_data_sync_mapfile.control.type            = changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in      = concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename        = concat_data_local.mapfile
make_concat_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_data_hosts.control.kind             = plugin
adjust_concat_data_hosts.control.type             = matchHosts
adjust_concat_data_hosts.control.mapfile_in       = concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match = make_concat_data_sync_mapfile.output.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type        = sync_files
sync_concat_data_to_local.control.mapfile_in  = concat_data.output.mapfile
sync_concat_data_to_local.control.mapfile_out = make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey    = msin
sync_concat_data_to_local.control.outputkey   = msout
sync_concat_data_to_local.argument.flags      = [msin,msout]

{% else %}
# make a mapfile for syncing of concat_blavg_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_blavg_data_sync_mapfile.control.kind            = plugin
make_concat_blavg_data_sync_mapfile.control.type            = changeDirectory
make_concat_blavg_data_sync_mapfile.control.mapfile_in      = concat_blavg_data.output.mapfile
make_concat_blavg_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_blavg_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_blavg_data_sync_mapfile.control.filename        = concat_blavg_data_local.mapfile
make_concat_blavg_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_blavg_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_blavg_data_hosts.control.kind             = plugin
adjust_concat_blavg_data_hosts.control.type             = matchHosts
adjust_concat_blavg_data_hosts.control.mapfile_in       = concat_blavg_data.output.mapfile
adjust_concat_blavg_data_hosts.control.mapfile_to_match = make_concat_blavg_data_sync_mapfile.output.mapfile

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in the apply steps will validate
adjust_concat_data_hosts.control.kind             = plugin
adjust_concat_data_hosts.control.type             = matchHosts
adjust_concat_data_hosts.control.mapfile_in       = concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match = make_concat_blavg_data_sync_mapfile.output.mapfile

# copy the output of concat_blavg_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_blavg_data_to_local.control.type        = sync_files
sync_concat_blavg_data_to_local.control.mapfile_in  = concat_blavg_data.output.mapfile
sync_concat_blavg_data_to_local.control.mapfile_out = make_concat_blavg_data_sync_mapfile.output.mapfile
sync_concat_blavg_data_to_local.control.inputkey    = msin
sync_concat_blavg_data_to_local.control.outputkey   = msout
sync_concat_blavg_data_to_local.argument.flags      = [msin,msout]
{% endif %}
{% endif %}

# make compressed mapfile for (non-local) concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind        = plugin
concat_data_compressed_mapfile.control.type        = compressMapfile
concat_data_compressed_mapfile.control.mapfile_in  = concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename    = concat_chunks_input.mapfile

{% block selfcal_parameters %}
########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                 = dppp
average0.control.mapfiles_in                          = [shift_cal.output.mapfile]
average0.control.inputkeys                            = [msin]
average0.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                     = DATA
average0.argument.msout.overwrite                     = True
average0.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average0.argument.steps                               = [avg]
average0.argument.avg.type                            = squash
average0.argument.avg.freqstep                        = 1
average0.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                = "Dysco"
average0.argument.msout.storagemanager.databitrate    = 16
average0.argument.msout.storagemanager.weightbitrate  = 12
average0.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation = 1.5
average0.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind        = plugin
create_compressed_mapfile0.control.type        = compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in  = shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in  = average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile0.control.filename    = concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type           = sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags         = [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename      = sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir   = input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts         = {{ hosts }}
sort_average0_into_Groups.argument.stepname      = sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB = False
sort_average0_into_Groups.argument.nband_pad     = {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind             = plugin
sort_average0_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap = sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap = sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 = dppp
concat_average0_data.control.mapfile_out                          = sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           = sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             = msin
concat_average0_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     = DATA
concat_average0_data.argument.msin.missingdata                    = True
concat_average0_data.argument.msin.orderms                        = False
concat_average0_data.argument.msout.overwrite                     = True
concat_average0_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               = []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                = "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    = 16
concat_average0_data.argument.msout.storagemanager.weightbitrate  = 12
concat_average0_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation = 1.5
concat_average0_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind        = plugin
create_compressed_mapfile01.control.type        = compressMapfile
create_compressed_mapfile01.control.mapfile_in  = concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile01.control.filename    = image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                   = make_clean_mask
premask_selfcal.control.mapfile_in             = create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey               = imagefile
premask_selfcal.control.outputkey              = maskfile
premask_selfcal.argument.flags                 = [imagefile,maskfile]
premask_selfcal.argument.img_format            = fits
premask_selfcal.argument.pad_to_size           = {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection = True
premask_selfcal.argument.vertices_file         = {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg      = {{ ra }}
premask_selfcal.argument.reference_dec_deg     = {{ dec }}
premask_selfcal.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file           = {{ region_selfcal }}
premask_selfcal.argument.make_blank_image      = True
premask_selfcal.argument.trim_by               = 0.4

# image the concatenated data with wsclean, length = 1
wsclean_image01.control.type                    = wsclean
wsclean_image01.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image01.control.inputkeys               = [msfile,fitsmask]
wsclean_image01.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image01.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image01.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image01.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image01.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image01.argument.niter                  = 10000
wsclean_image01.argument.pol                    = I
wsclean_image01.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image01.argument.mgain                  = 0.8
wsclean_image01.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image01.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image01.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image01.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image01.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image01.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image01.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image01.argument.multiscale-scales      = 0
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image01.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image01.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image01.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image01.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image01.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image01.argument.auto-mask              = 2.6
{% else %}
wsclean_image01.argument.auto-mask              = 3.6
{% endif %}
{% if use_idg %}
wsclean_image01.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image01.argument.auto-threshold         = 0.5
wsclean_image01.argument.local-rms-window       = 50
wsclean_image01.argument.local-rms-method       = rms-with-min

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map01.control.kind        = plugin
create_imagebase_map01.control.type        = trimMapfile
create_imagebase_map01.control.mapfile_in  = wsclean_image01.output.wsclean_image01-image.fits.mapfile
create_imagebase_map01.control.trim        = -
create_imagebase_map01.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map01.control.filename    = wsclean_image01_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile01.control.kind        = plugin
adjust_wsclean_mapfile01.control.type        = appendMapfile
adjust_wsclean_mapfile01.control.mapfile_in  = create_imagebase_map01.output.mapfile
adjust_wsclean_mapfile01.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile01.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile01.control.filename    = adjust_wsclean_mapfile01.mapfile

# make a mask, length = 1
mask0.control.type                = make_clean_mask
mask0.control.mapfile_in          = adjust_wsclean_mapfile01.output.mapfile
mask0.control.inputkey            = imagefile
mask0.control.outputkey           = maskfile
mask0.argument.flags              = [imagefile,maskfile]
mask0.argument.region_file        = {{ region_field }}
mask0.argument.threshisl          = 6
mask0.argument.threshpix          = 8
mask0.argument.rmsbox             = (80,20)
mask0.argument.adaptive_rmsbox    = True
mask0.argument.atrous_do          = False
mask0.argument.img_format         = fits
mask0.argument.vertices_file      = {{ vertices_file }}
mask0.argument.exclude_cal_region = False
mask0.argument.dilate             = 2

# image the concatenated data with wsclean, length = 1
wsclean_image02.control.type                    = wsclean
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask]
wsclean_image02.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image02.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image02.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.niter                  = 10000
wsclean_image02.argument.pol                    = I
wsclean_image02.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                  = 0.8
wsclean_image02.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image02.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image02.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image02.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image02.argument.multiscale-scales      = 0
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image02.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image02.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image02.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image02.argument.auto-mask              = 2.6
{% else %}
wsclean_image02.argument.auto-mask              = 3.6
{% endif %}
{% if use_idg %}
wsclean_image02.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image02.argument.auto-threshold         = 0.5
wsclean_image02.argument.local-rms-window       = 50
wsclean_image02.argument.local-rms-method       = rms-with-min

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind               = plugin
regroup_concat_data_map.control.type               = compressMapfile
regroup_concat_data_map.control.mapfile_in         = {{ solve_concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress = {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir        = input.output.mapfile_dir
regroup_concat_data_map.control.filename           = regroup_concat_data.mapfile

# generate mapfile for the fast-phase h5parms generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_h5parm_map.control.kind               = plugin
make_fast_phase_h5parm_map.control.type               = createMapfile
make_fast_phase_h5parm_map.control.method             = add_suffix_to_file
make_fast_phase_h5parm_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_h5parm_map.control.add_suffix_to_file = /instrument.h5
make_fast_phase_h5parm_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_h5parm_map.control.filename           = fast_h5parm.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier sky model from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier sky model into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob
make_peel_sourcedb.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile

{% else %}

# group the WSClean sky model into a single patch, length = 1
group_skymodel0.control.type       = group_skymodel
group_skymodel0.control.mapfile_in = wsclean_image02.output.wsclean_image02-sources.txt.mapfile
group_skymodel0.control.inputkey   = inmod
group_skymodel0.control.outputkey  = outmod
group_skymodel0.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb0.control.type       = make_sourcedb
make_sourcedb0.control.mapfile_in = group_skymodel0.output.mapfile
make_sourcedb0.control.inputkey   = in
make_sourcedb0.argument.format    = <
make_sourcedb0.argument.outtype   = blob
make_sourcedb0.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb0_map.control.kind             = plugin
expand_sourcedb0_map.control.type             = expandMapfile
expand_sourcedb0_map.control.mapfile_in       = make_sourcedb0.output.mapfile
expand_sourcedb0_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb0_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb0_map.control.filename         = expand_sourcedb0.mapfile
{% endif %}

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms1.control.type       = remove_file
remove_h5parms1.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms1.control.inputkey   = h5parm
remove_h5parms1.argument.flags     = [-rf,h5parm]

# run DDECal with sourcedb on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_phaseonly1.control.type                         = dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
{% else %}
solve_phaseonly1.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb0_map.output.mapfile]
{% endif %}
solve_phaseonly1.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_phaseonly1.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn             = DATA
solve_phaseonly1.argument.msout                       = .
solve_phaseonly1.argument.steps                       = [solvetec]
solve_phaseonly1.argument.solvetec.type               = ddecal
solve_phaseonly1.argument.solvetec.mode               = tecandphase
solve_phaseonly1.argument.solvetec.h5parm             = h5parm
solve_phaseonly1.argument.solvetec.sourcedb           = sourcedb
solve_phaseonly1.argument.solvetec.solint             = {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_phaseonly1.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_phaseonly1.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_phaseonly1.argument.solvetec.maxiter            = {{ maxiter }}
solve_phaseonly1.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_phaseonly1.argument.solvetec.stepsize           = {{ stepsize }}
solve_phaseonly1.argument.solvetec.tolerance          = {{ tolerance }}
solve_phaseonly1.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

########## end of first round of selfcal
########## start of second round of selfcal

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the shared disk if one is being
# used with mulitple nodes
make_apply_mapfile.control.kind         = plugin
make_apply_mapfile.control.type         = changeDirectory
{% if not pre_average %}
make_apply_mapfile.control.mapfile_in   = make_concat_data_sync_mapfile.output.mapfile
{% else %}
make_apply_mapfile.control.mapfile_in   = make_concat_blavg_data_sync_mapfile.output.mapfile
{% endif %}
make_apply_mapfile.control.new_dir      = {{ pipeline_parset_dir }}
make_apply_mapfile.control.append       = _apply_output
make_apply_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_apply_mapfile.control.filename     = apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 = dppp
apply_phaseonly1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_phaseonly1.control.inputkeys                            = [msin,h5parm]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     = DATA
apply_phaseonly1.argument.msout.overwrite                     = True
apply_phaseonly1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly1.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type                  = applycal
apply_phaseonly1.argument.correct_fast1.parmdb                = h5parm
apply_phaseonly1.argument.correct_fast1.correction            = tec000
apply_phaseonly1.argument.correct_fast1.invert                = True
apply_phaseonly1.argument.correct_fast2.type                  = applycal
apply_phaseonly1.argument.correct_fast2.parmdb                = h5parm
apply_phaseonly1.argument.correct_fast2.correction            = phase000
apply_phaseonly1.argument.correct_fast2.invert                = True
apply_phaseonly1.argument.avg.type                            = squash
apply_phaseonly1.argument.avg.freqstep                        = 1
apply_phaseonly1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                = "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind        = plugin
create_compressed_mapfile1.control.type        = compressMapfile
create_compressed_mapfile1.control.mapfile_in  = apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile1.control.filename    = image1_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image12.control.type                    = wsclean
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask]
wsclean_image12.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image12.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image12.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.niter                  = 10000
wsclean_image12.argument.pol                    = I
wsclean_image12.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                  = 0.8
wsclean_image12.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image12.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image12.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image12.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image12.argument.multiscale-scales      = 0
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image12.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image12.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image12.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image12.argument.auto-mask              = 2.3
{% else %}
wsclean_image12.argument.auto-mask              = 3.3
{% endif %}
{% if use_idg %}
wsclean_image12.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image12.argument.auto-threshold         = 0.5
wsclean_image12.argument.local-rms-window       = 50
wsclean_image12.argument.local-rms-method       = rms-with-min

# group the WSClean sky model into a single patch, length = 1
group_skymodel1.control.type       = group_skymodel
group_skymodel1.control.mapfile_in = wsclean_image12.output.wsclean_image12-sources.txt.mapfile
group_skymodel1.control.inputkey   = inmod
group_skymodel1.control.outputkey  = outmod
group_skymodel1.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb1.control.type       = make_sourcedb
make_sourcedb1.control.mapfile_in = group_skymodel1.output.mapfile
make_sourcedb1.control.inputkey   = in
make_sourcedb1.argument.format    = <
make_sourcedb1.argument.outtype   = blob
make_sourcedb1.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb1_map.control.kind             = plugin
expand_sourcedb1_map.control.type             = expandMapfile
expand_sourcedb1_map.control.mapfile_in       = make_sourcedb1.output.mapfile
expand_sourcedb1_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb1_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb1_map.control.filename         = expand_sourcedb1.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms2.control.type       = remove_file
remove_h5parms2.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms2.control.inputkey   = h5parm
remove_h5parms2.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_phaseonly2.control.type                         = dppp_inplace
solve_phaseonly2.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,,expand_sourcedb1_map.output.mapfile]
solve_phaseonly2.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_phaseonly2.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn             = DATA
solve_phaseonly2.argument.msout                       = .
solve_phaseonly2.argument.steps                       = [solvetec]
solve_phaseonly2.argument.solvetec.type               = ddecal
solve_phaseonly2.argument.solvetec.mode               = tecandphase
solve_phaseonly2.argument.solvetec.h5parm             = h5parm
solve_phaseonly2.argument.solvetec.sourcedb           = sourcedb
solve_phaseonly2.argument.solvetec.solint             = {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_phaseonly2.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_phaseonly2.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_phaseonly2.argument.solvetec.maxiter            = {{ maxiter }}
solve_phaseonly2.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_phaseonly2.argument.solvetec.stepsize           = {{ stepsize }}
solve_phaseonly2.argument.solvetec.tolerance          = {{ tolerance }}
solve_phaseonly2.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                                 = dppp
apply_phaseonly2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_phaseonly2.control.inputkeys                            = [msin,h5parm]
{% if selfcal_local_dir is not none %}
apply_phaseonly2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn                     = DATA
apply_phaseonly2.argument.msout.overwrite                     = True
apply_phaseonly2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly2.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly2.argument.correct_fast1.type                  = applycal
apply_phaseonly2.argument.correct_fast1.parmdb                = h5parm
apply_phaseonly2.argument.correct_fast1.correction            = tec000
apply_phaseonly2.argument.correct_fast1.invert                = True
apply_phaseonly2.argument.correct_fast2.type                  = applycal
apply_phaseonly2.argument.correct_fast2.parmdb                = h5parm
apply_phaseonly2.argument.correct_fast2.correction            = phase000
apply_phaseonly2.argument.correct_fast2.invert                = True
apply_phaseonly2.argument.avg.type                            = squash
apply_phaseonly2.argument.avg.freqstep                        = 1
apply_phaseonly2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly2.argument.msout.storagemanager                = "Dysco"
apply_phaseonly2.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly2.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly2.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind        = plugin
create_compressed_mapfile2.control.type        = compressMapfile
create_compressed_mapfile2.control.mapfile_in  = apply_phaseonly2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile2.control.filename    = image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image22.control.type                    = wsclean
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask]
wsclean_image22.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image22.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image22.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.niter                  = 10000
wsclean_image22.argument.pol                    = I
wsclean_image22.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                  = 0.8
wsclean_image22.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image22.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image22.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image22.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image22.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image22.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image22.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image22.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image22.argument.auto-mask              = 2.0
{% else %}
wsclean_image22.argument.auto-mask              = 3.0
{% endif %}
{% if use_idg %}
wsclean_image22.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image22.argument.auto-threshold         = 0.5
wsclean_image22.argument.local-rms-window       = 50
wsclean_image22.argument.local-rms-method       = rms-with-min
wsclean_image22.argument.multiscale-scale-bias  = 0.5
wsclean_image22.argument.multiscale-gain        = 0.1

# group the WSClean sky model into a single patch, length = 1
group_skymodel2.control.type       = group_skymodel
group_skymodel2.control.mapfile_in = wsclean_image22.output.wsclean_image22-sources.txt.mapfile
group_skymodel2.control.inputkey   = inmod
group_skymodel2.control.outputkey  = outmod
group_skymodel2.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb2.control.type       = make_sourcedb
make_sourcedb2.control.mapfile_in = group_skymodel2.output.mapfile
make_sourcedb2.control.inputkey   = in
make_sourcedb2.argument.format    = <
make_sourcedb2.argument.outtype   = blob
make_sourcedb2.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb2_map.control.kind             = plugin
expand_sourcedb2_map.control.type             = expandMapfile
expand_sourcedb2_map.control.mapfile_in       = make_sourcedb2.output.mapfile
expand_sourcedb2_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb2_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb2_map.control.filename         = expand_sourcedb2.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms11.control.type       = remove_file
remove_h5parms11.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms11.control.inputkey   = h5parm
remove_h5parms11.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_ampphase11.control.type                         = dppp_inplace
solve_ampphase11.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb2_map.output.mapfile]
solve_ampphase11.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_ampphase11.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn             = DATA
solve_ampphase11.argument.msout                       = .
solve_ampphase11.argument.steps                       = [solvetec]
solve_ampphase11.argument.solvetec.type               = ddecal
solve_ampphase11.argument.solvetec.mode               = tecandphase
solve_ampphase11.argument.solvetec.h5parm             = h5parm
solve_ampphase11.argument.solvetec.sourcedb           = sourcedb
solve_ampphase11.argument.solvetec.solint             = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_ampphase11.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_ampphase11.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_ampphase11.argument.solvetec.maxiter            = {{ maxiter }}
solve_ampphase11.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_ampphase11.argument.solvetec.stepsize           = {{ stepsize }}
solve_ampphase11.argument.solvetec.tolerance          = {{ tolerance }}
solve_ampphase11.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,h5parm]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = h5parm
apply_ampphase11.argument.correct_fast1.correction            = tec000
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = h5parm
apply_ampphase11.argument.correct_fast2.correction            = phase000
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# generate mapfile for the slow-gain h5parms generated in the solve_ampphase12 step, length = ntimes * num_cal_blocks
make_slow_gain_h5parm_map.control.kind               =  plugin
make_slow_gain_h5parm_map.control.type               =  createMapfile
make_slow_gain_h5parm_map.control.method             =  add_suffix_to_file
make_slow_gain_h5parm_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_h5parm_map.control.add_suffix_to_file =  /instrument_slow.h5
make_slow_gain_h5parm_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_h5parm_map.control.filename           =  slow_h5parm.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms12.control.type       = remove_file
remove_h5parms12.control.mapfile_in = make_slow_gain_h5parm_map.output.mapfile
remove_h5parms12.control.inputkey   = h5parm
remove_h5parms12.argument.flags     = [-rf,h5parm]

# run DDECAl with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
solve_ampphase12.control.type                            = dppp_inplace
solve_ampphase12.control.mapfiles_in                     = [{{ solve_concat_data_mapfile }},make_slow_gain_h5parm_map.output.mapfile,expand_sourcedb2_map.output.mapfile]
solve_ampphase12.control.inputkeys                       = [msin,h5parm,sourcedb]
solve_ampphase12.argument.numthreads                     = {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                = CORRECTED_DATA
solve_ampphase12.argument.msout                          = .
solve_ampphase12.argument.steps                          = [solvegain]
solve_ampphase12.argument.solvegain.type                 = ddecal
solve_ampphase12.argument.solvegain.mode                 = complexgain
solve_ampphase12.argument.solvegain.h5parm               = h5parm
solve_ampphase12.argument.solvegain.sourcedb             = sourcedb
solve_ampphase12.argument.solvegain.solint               = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                = {{ solint_freq_a }}
solve_ampphase12.argument.solvegain.maxiter              = {{ maxiter }}
solve_ampphase12.argument.solvegain.propagatesolutions   = {{ propagatesolutions }}
solve_ampphase12.argument.solvegain.stepsize             = {{ stepsize }}
solve_ampphase12.argument.solvegain.tolerance            = {{ tolerance }}
solve_ampphase12.argument.solvegain.uvlambdamin          = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.smoothnessconstraint = 6e6

# compress slow-gain mapfile so that all files are in one group, length = 1
create_compressed_mapfile_slow.control.kind        = plugin
create_compressed_mapfile_slow.control.type        = compressMapfile
create_compressed_mapfile_slow.control.mapfile_in  = make_slow_gain_h5parm_map.output.mapfile
create_compressed_mapfile_slow.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_slow.control.filename    = compress_slow.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_slow_output_map.control.kind        = plugin
create_combined_slow_output_map.control.type        = addListMapfile
create_combined_slow_output_map.control.hosts       = {{ hosts }}
create_combined_slow_output_map.control.files       = [input.output.working_directory/input.output.job_name/slow_gains.h5]
create_combined_slow_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_slow_output_map.control.filename    = combine_slow_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_slow.control.kind             = plugin
match_host_slow.control.type             = matchHosts
match_host_slow.control.mapfile_in       = create_compressed_mapfile_slow.output.mapfile
match_host_slow.control.mapfile_to_match = create_combined_slow_output_map.output.mapfile
match_host_slow.control.mapfile_dir      = input.output.mapfile_dir
match_host_slow.control.filename         = match_host_slow.mapfile

# collect all the slow-gain solutions, length = ntimes -> 1
combine_slow_gains1.control.type        = collect_h5parms
combine_slow_gains1.control.mapfile_in  = create_compressed_mapfile_slow.output.mapfile
combine_slow_gains1.control.inputkey    = infiles
combine_slow_gains1.control.mapfile_out = create_combined_slow_output_map.output.mapfile
combine_slow_gains1.control.outputkey   = outfile
combine_slow_gains1.argument.flags      = [-c,infiles]
combine_slow_gains1.argument.outh5parm  = outfile

# smooth the amplitues in the merged h5parm, length = 1
smooth_amp1.control.type         = {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in   = combine_slow_gains1.output.mapfile
smooth_amp1.control.inputkey     = amph5parm
smooth_amp1.argument.flags       = [amph5parm]

# expand the mapfile with the smoothd h5parm to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_h5parm_map.control.kind             = plugin
expand_smoothed_amp1_h5parm_map.control.type             = expandMapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_in       = smooth_amp1.output.mapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp1_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp1_h5parm_map.control.filename         = expand_amp1_smoothed_h5parms.mapfile

# apply the solutions and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp1_h5parm_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,slow_h5parm]
apply_amp1.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp1.argument.steps                               = [correct_slow_amp,correct_slow_phase,avg]
{% else %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_smoothed_amp1_h5parm_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,fast_h5parmdb,slow_h5parm]
apply_amp1.argument.msin.datacolumn                     = DATA
apply_amp1.argument.steps                               = [correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,avg]
apply_amp1.argument.correct_fast1.type                  = applycal
apply_amp1.argument.correct_fast1.parmdb                = fast_h5parmdb
apply_amp1.argument.correct_fast1.correction            = tec000
apply_amp1.argument.correct_fast1.invert                = True
apply_amp1.argument.correct_fast2.type                  = applycal
apply_amp1.argument.correct_fast2.parmdb                = fast_h5parmdb
apply_amp1.argument.correct_fast2.correction            = phase000
apply_amp1.argument.correct_fast2.invert                = True
{% endif %}
apply_amp1.argument.msout.overwrite                     = True
apply_amp1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp1.argument.correct_slow_amp.type               = applycal
apply_amp1.argument.correct_slow_amp.parmdb             = slow_h5parm
apply_amp1.argument.correct_slow_amp.correction         = amplitude001
apply_amp1.argument.correct_slow_amp.invert             = True
apply_amp1.argument.correct_slow_phase.type             = applycal
apply_amp1.argument.correct_slow_phase.parmdb           = slow_h5parm
apply_amp1.argument.correct_slow_phase.correction       = phase000
apply_amp1.argument.correct_slow_phase.invert           = True
apply_amp1.argument.avg.type                            = squash
apply_amp1.argument.avg.freqstep                        = 1
apply_amp1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                = "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate    = 16
apply_amp1.argument.msout.storagemanager.weightbitrate  = 12
apply_amp1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation = 1.5
apply_amp1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind        = plugin
create_compressed_mapfile3.control.type        = compressMapfile
create_compressed_mapfile3.control.mapfile_in  = apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile3.control.filename    = image3_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image32.control.type                    = wsclean
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask]
wsclean_image32.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image32.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image32.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.niter                  = 10000
wsclean_image32.argument.pol                    = I
wsclean_image32.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                  = 0.8
wsclean_image32.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image32.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image32.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image32.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image32.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image32.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image32.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image32.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image32.argument.auto-mask              = 2.5
{% else %}
wsclean_image32.argument.auto-mask              = 3.5
{% endif %}
{% if use_idg %}
wsclean_image32.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image32.argument.auto-threshold         = 0.5
wsclean_image32.argument.local-rms-window       = 50
wsclean_image32.argument.local-rms-method       = rms-with-min
wsclean_image32.argument.multiscale-scale-bias  = 0.5
wsclean_image32.argument.multiscale-gain        = 0.1

########## start of selfcal loop

# loop step
loop_ampcal.control.kind      = loop
loop_ampcal.control.type      = conditional
loop_ampcal.control.loopcount = {{ loopcount }}
loop_ampcal.control.loopsteps = [group_skymodel3,make_sourcedb3,expand_sourcedb3_map,remove_h5parms21,solve_ampphase21,apply_ampphase21,create_compressed_mapfile_fast,create_combined_fast_output_map,match_host_fast,merge_phase_h5parms,remove_h5parms22,solve_ampphase22,combine_slow_gains2,smooth_amp2,expand_smoothed_amp2_h5parm_map,apply_amp2,create_compressed_mapfile4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image,check_image]

# group the WSClean sky model into a single patch, length = 1
group_skymodel3.control.type       = group_skymodel
group_skymodel3.control.mapfile_in = wsclean_image32.output.wsclean_image32-sources.txt.mapfile
group_skymodel3.control.inputkey   = inmod
group_skymodel3.control.outputkey  = outmod
group_skymodel3.argument.flags     = [inmod,outmod]

# convert the WSClean sky model into a sourcedb, length = 1
make_sourcedb3.control.type       = make_sourcedb
make_sourcedb3.control.mapfile_in = group_skymodel3.output.mapfile
make_sourcedb3.control.inputkey   = in
make_sourcedb3.argument.format    = <
make_sourcedb3.argument.outtype   = blob
make_sourcedb3.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_sourcedb3_map.control.kind             = plugin
expand_sourcedb3_map.control.type             = expandMapfile
expand_sourcedb3_map.control.mapfile_in       = make_sourcedb3.output.mapfile
expand_sourcedb3_map.control.mapfile_to_match = concat_data.output.mapfile
expand_sourcedb3_map.control.mapfile_dir      = input.output.mapfile_dir
expand_sourcedb3_map.control.filename         = expand_sourcedb3.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms21.control.type       = remove_file
remove_h5parms21.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms21.control.inputkey   = h5parm
remove_h5parms21.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_ampphase21.control.type                         = dppp_inplace
solve_ampphase21.control.mapfiles_in                  = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_sourcedb3_map.output.mapfile]
solve_ampphase21.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_ampphase21.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn             = DATA
solve_ampphase21.argument.msout                       = .
solve_ampphase21.argument.steps                       = [solvetec]
solve_ampphase21.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type               = ddecal
solve_ampphase21.argument.solvetec.mode               = tecandphase
solve_ampphase21.argument.solvetec.h5parm             = h5parm
solve_ampphase21.argument.solvetec.sourcedb           = sourcedb
solve_ampphase21.argument.solvetec.solint             = {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_ampphase21.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_ampphase21.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_ampphase21.argument.solvetec.maxiter            = {{ maxiter }}
solve_ampphase21.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_ampphase21.argument.solvetec.stepsize           = {{ stepsize }}
solve_ampphase21.argument.solvetec.tolerance          = {{ tolerance }}
solve_ampphase21.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 = dppp_inplace
apply_ampphase21.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_ampphase21.control.inputkeys                            = [msin,h5parm]
apply_ampphase21.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     = DATA
apply_ampphase21.argument.msout                               = .
apply_ampphase21.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase21.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type                  = applycal
apply_ampphase21.argument.correct_fast1.parmdb                = h5parm
apply_ampphase21.argument.correct_fast1.correction            = tec000
apply_ampphase21.argument.correct_fast1.invert                = True
apply_ampphase21.argument.correct_fast2.type                  = applycal
apply_ampphase21.argument.correct_fast2.parmdb                = h5parm
apply_ampphase21.argument.correct_fast2.correction            = phase000
apply_ampphase21.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                = "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    = 16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase21.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase21.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress fast-phase mapfile so that all files are in one group, length = 1
create_compressed_mapfile_fast.control.kind        = plugin
create_compressed_mapfile_fast.control.type        = compressMapfile
create_compressed_mapfile_fast.control.mapfile_in  = make_fast_phase_h5parm_map.output.mapfile
create_compressed_mapfile_fast.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_fast.control.filename    = compress_fast.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_fast_output_map.control.kind        = plugin
create_combined_fast_output_map.control.type        = addListMapfile
create_combined_fast_output_map.control.hosts       = {{ hosts }}
create_combined_fast_output_map.control.files       = [input.output.working_directory/input.output.job_name/fast_phases.h5]
create_combined_fast_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_fast_output_map.control.filename    = combine_fast_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_fast.control.kind             = plugin
match_host_fast.control.type             = matchHosts
match_host_fast.control.mapfile_in       = create_compressed_mapfile_fast.output.mapfile
match_host_fast.control.mapfile_to_match = create_combined_fast_output_map.output.mapfile
match_host_fast.control.mapfile_dir      = input.output.mapfile_dir
match_host_fast.control.filename         = match_host_slow.mapfile

# merge the h5parms with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_h5parms.control.type        = collect_h5parms
merge_phase_h5parms.control.mapfile_in  = create_compressed_mapfile_fast.output.mapfile
merge_phase_h5parms.control.inputkey    = infiles
merge_phase_h5parms.control.mapfile_out = create_combined_fast_output_map.output.mapfile
merge_phase_h5parms.control.outputkey   = outfile
merge_phase_h5parms.argument.flags      = [-c,infiles]
merge_phase_h5parms.argument.outh5parm  = outfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms22.control.type       = remove_file
remove_h5parms22.control.mapfile_in = make_slow_gain_h5parm_map.output.mapfile
remove_h5parms22.control.inputkey   = h5parm
remove_h5parms22.argument.flags     = [-rf,h5parm]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
solve_ampphase22.control.type                            = dppp_inplace
solve_ampphase22.control.mapfiles_in                     = [{{ solve_concat_data_mapfile }},make_slow_gain_h5parm_map.output.mapfile,expand_sourcedb3_map.output.mapfile]
solve_ampphase22.control.inputkeys                       = [msin,h5parm,sourcedb]
solve_ampphase22.argument.numthreads                     = {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn                = CORRECTED_DATA
solve_ampphase22.argument.msout                          = .
solve_ampphase22.argument.steps                          = [solvegain]
solve_ampphase22.argument.solvegain.type                 = ddecal
solve_ampphase22.argument.solvegain.mode                 = complexgain
solve_ampphase22.argument.solvegain.h5parm               = h5parm
solve_ampphase22.argument.solvegain.sourcedb             = sourcedb
solve_ampphase22.argument.solvegain.solint               = {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan                = {{ solint_freq_a }}
solve_ampphase22.argument.solvegain.maxiter              = {{ maxiter }}
solve_ampphase22.argument.solvegain.propagatesolutions   = {{ propagatesolutions }}
solve_ampphase22.argument.solvegain.stepsize             = {{ stepsize }}
solve_ampphase22.argument.solvegain.tolerance            = {{ tolerance }}
solve_ampphase22.argument.solvegain.uvlambdamin          = {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.smoothnessconstraint = 6e6

# merge the h5parms with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
# collect all the slow-gain solutions, length = ntimes -> 1
combine_slow_gains2.control.type        = collect_h5parms
combine_slow_gains2.control.mapfile_in  = create_compressed_mapfile_slow.output.mapfile
combine_slow_gains2.control.inputkey    = infiles
combine_slow_gains2.control.mapfile_out = create_combined_slow_output_map.output.mapfile
combine_slow_gains2.control.outputkey   = outfile
combine_slow_gains2.argument.flags      = [-c,infiles]
combine_slow_gains2.argument.outh5parm  = outfile

# smooth the amplitues in the merged h5parm, length = 1
smooth_amp2.control.type         = {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in   = combine_slow_gains2.output.mapfile
smooth_amp2.control.inputkey     = amph5parm
smooth_amp2.argument.flags       = [amph5parm]

# expand the mapfile with the smoothd h5parm to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_h5parm_map.control.kind             = plugin
expand_smoothed_amp2_h5parm_map.control.type             = expandMapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_in       = smooth_amp2.output.mapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp2_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp2_h5parm_map.control.filename         = expand_amp2_smoothed_h5parms.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp2_h5parm_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,slow_h5parm]
apply_amp2.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp2.argument.steps                               = [correct_slow_amp,correct_slow_phase,avg]
{% else %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_smoothed_amp2_h5parm_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,fast_h5parmdb,slow_h5parm]
apply_amp2.argument.msin.datacolumn                     = DATA
apply_amp2.argument.steps                               = [correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,avg]
apply_amp2.argument.correct_fast1.type                  = applycal
apply_amp2.argument.correct_fast1.parmdb                = fast_h5parmdb
apply_amp2.argument.correct_fast1.correction            = tec000
apply_amp2.argument.correct_fast1.invert                = True
apply_amp2.argument.correct_fast2.type                  = applycal
apply_amp2.argument.correct_fast2.parmdb                = fast_h5parmdb
apply_amp2.argument.correct_fast2.correction            = phase000
apply_amp2.argument.correct_fast2.invert                = True
{% endif %}
apply_amp2.argument.msout.overwrite                     = True
apply_amp2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp2.argument.correct_slow_amp.type               = applycal
apply_amp2.argument.correct_slow_amp.parmdb             = slow_h5parm
apply_amp2.argument.correct_slow_amp.correction         = amplitude001
apply_amp2.argument.correct_slow_amp.invert             = True
apply_amp2.argument.correct_slow_phase.type             = applycal
apply_amp2.argument.correct_slow_phase.parmdb           = slow_h5parm
apply_amp2.argument.correct_slow_phase.correction       = phase000
apply_amp2.argument.correct_slow_phase.invert           = True
apply_amp2.argument.avg.type                            = squash
apply_amp2.argument.avg.freqstep                        = 1
apply_amp2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                = "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate    = 16
apply_amp2.argument.msout.storagemanager.weightbitrate  = 12
apply_amp2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation = 1.5
apply_amp2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind        = plugin
create_compressed_mapfile4.control.type        = compressMapfile
create_compressed_mapfile4.control.mapfile_in  = apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile4.control.filename    = image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image42.control.type                    = wsclean
wsclean_image42.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image42.control.inputkeys               = [msfile,fitsmask]
wsclean_image42.argument.fits-mask              = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-join-channels,-save-source-list,{{ idg_arg }}msfile]
wsclean_image42.argument.channels-out           = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fit-beam,-reorder,-local-rms,-save-source-list,{{ idg_arg }}msfile]
{% endif %}
wsclean_image42.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.niter                  = 10000
wsclean_image42.argument.pol                    = I
wsclean_image42.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                  = 0.8
wsclean_image42.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image42.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.temp-dir               = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image42.argument.temp-dir               = {{ selfcal_local_dir }}
{% endif %}
wsclean_image42.argument.multiscale-shape       = gaussian
{% if not mscale_selfcal_do %}
wsclean_image42.argument.multiscale-scales      = 0,7
{% elif selfcal_multiscale_scales_pixel is not none %}
wsclean_image42.argument.multiscale-scales      = {{ selfcal_multiscale_scales_pixel }}
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image42.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image42.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image42.argument.auto-mask              = 2.0
{% else %}
wsclean_image42.argument.auto-mask              = 3.0
{% endif %}
{% if use_idg %}
wsclean_image42.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image42.argument.auto-threshold         = 0.5
wsclean_image42.argument.local-rms-window       = 50
wsclean_image42.argument.local-rms-method       = rms-with-min
wsclean_image42.argument.multiscale-scale-bias  = 0.5
wsclean_image42.argument.multiscale-gain        = 0.1

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind        = plugin
create_imagebase_map42.control.type        = trimMapfile
create_imagebase_map42.control.mapfile_in  = wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim        = -
create_imagebase_map42.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map42.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind        = plugin
adjust_wsclean_mapfile42.control.type        = appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in  = create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename    = compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image.control.type       = copy_image
copy_image.control.mapfile_in = adjust_wsclean_mapfile42.output.mapfile
copy_image.control.inputkey   = image
copy_image.argument.flags     = [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image.control.type        = compare_image_stats
check_image.control.mapfiles_in = [adjust_wsclean_mapfile42.output.mapfile,copy_image.output.previous_image.mapfile]
check_image.control.inputkeys   = [image_new,image_prev]
check_image.argument.flags      = [image_new,image_prev]

########## end of selfcal loop
{% endblock selfcal_parameters %}

{% if selfcal_local_dir is not none %}
{% if not pre_average %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type       = remove_synced_data
remove_concat_data.control.mapfile_in = make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey   = msfile
remove_concat_data.argument.flags     = [msfile]

{% else %}
# remove concat_blavg_data files, length = ntimes * num_cal_blocks
remove_concat_blavg_data.control.type       = remove_synced_data
remove_concat_blavg_data.control.mapfile_in = make_concat_blavg_data_sync_mapfile.output.mapfile
remove_concat_blavg_data.control.inputkey   = msfile
remove_concat_blavg_data.argument.flags     = [msfile]
{% endif %}
{% endif %}

# create a mapfile for output of combine step, length = 1
create_combined_output_map.control.kind        = plugin
create_combined_output_map.control.type        = addListMapfile
create_combined_output_map.control.hosts       = {{ hosts }}
create_combined_output_map.control.files       = [input.output.working_directory/input.output.job_name/combined_solutions.h5]
create_combined_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_output_map.control.filename    = combine_all_h5parms_output.mapfile

# combine fast and slow h5parms, length = 2 -> 1
combine_h5parms.control.type        = combine_h5parms
combine_h5parms.control.mapfiles_in = [create_combined_fast_output_map.output.mapfile,create_combined_slow_output_map.output.mapfile]
combine_h5parms.control.inputkeys   = [h1,h2]
combine_h5parms.control.mapfile_out = create_combined_output_map.output.mapfile
combine_h5parms.control.outputkey   = outfile
combine_h5parms.argument.flags      = [h1,h2,outfile]

# expand the h5parm mapfile so that there is one entry for every file, length = nfiles
expand_combined_h5parm.control.kind             = plugin
expand_combined_h5parm.control.type             = expandMapfile
expand_combined_h5parm.control.mapfile_in       = create_combined_output_map.output.mapfile
expand_combined_h5parm.control.mapfile_to_match = create_ms_map.output.mapfile
expand_combined_h5parm.control.mapfile_dir      = input.output.mapfile_dir
expand_combined_h5parm.control.filename         = expand_combined_h5parm.mapfile

# make plots of the selfcal solutions from the merged parmDB, length = 1
make_selfcal_plots.control.type       = make_selfcal_plots
make_selfcal_plots.control.mapfile_in = combine_h5parms.output.mapfile
make_selfcal_plots.control.inputkeys  = h5parm
make_selfcal_plots.argument.flags     = [h5parm]

# create a mapfile with the selfcal images, length = 1
create_selfcal_images_mapfile.control.kind        = plugin
create_selfcal_images_mapfile.control.type        = addSelfcalImagesMapfile
create_selfcal_images_mapfile.control.selfcal_dir = {{ pipeline_parset_dir }}
create_selfcal_images_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_selfcal_images_mapfile.control.hosts       = {{ hosts }}
create_selfcal_images_mapfile.control.filename    = selfcal_images.mapfile

# make plots of the selfcal images, length = 1
make_selfcal_images.control.type       = make_selfcal_images
make_selfcal_images.control.mapfile_in = create_selfcal_images_mapfile.output.mapfile
make_selfcal_images.control.inputkeys  = imagefiles
make_selfcal_images.argument.flags     = [imagefiles]

# create a mapfile for the last calibrator sky model, length = 1
create_model4_map.control.kind        = plugin
create_model4_map.control.type        = trimMapfile
create_model4_map.control.mapfile_in  = wsclean_image42.output.wsclean_image42-model.fits.mapfile
create_model4_map.control.trim        = -
create_model4_map.control.mapfile_dir = input.output.mapfile_dir
create_model4_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model4_map.control.kind             = plugin
expand_model4_map.control.type             = expandMapfile
expand_model4_map.control.mapfile_in       = create_model4_map.output.mapfile
expand_model4_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model4_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model4_map.control.filename         = expand_model4_map.mapfile

# Blank (with zeros) regions of the mask that lie outside of the patch region, length = 1
blank_mask.control.type                    = blank_image
blank_mask.control.mapfile_in              = premask_selfcal.output.mapfile
blank_mask.control.inputkey                = infile
blank_mask.control.outputkey               = outfile
blank_mask.argument.flags                  = [infile,{{ vertices_file }},outfile]
blank_mask.argument.blank_value            = zero
blank_mask.argument.image_is_wsclean_model = False

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask4_map.control.kind             = plugin
expand_mask4_map.control.type             = expandMapfile
expand_mask4_map.control.mapfile_in       = blank_mask.output.mapfile
expand_mask4_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask4_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask4_map.control.filename         = expand_mask4_map.mapfile

# make the new calibrator sky model, len = nbands
make_new_cal_skymodel.control.type        = poly2sky
make_new_cal_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model4_map.output.mapfile,expand_mask4_map.output.mapfile]
make_new_cal_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_new_cal_skymodel.control.outputkey   = skymodel
make_new_cal_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

{% if not is_patch or mscale_selfcal_do %}
# Image the full facet at high-res to improve the model (if direction is a patch,
# and mscale_selfcal_do is True, we do this but skip the high-res imaging
# as we already have such an image from selfcal)

# extract the skymodel for the full facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type       = make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey   = fullmodelfile
make_facet_skymodels_all.control.outputkey  = outfile
make_facet_skymodels_all.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type       = make_sourcedb
make_sourcedb_all_facet_sources.control.mapfile_in = make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.inputkey   = in
make_sourcedb_all_facet_sources.argument.format    = <
make_sourcedb_all_facet_sources.argument.outtype   = blob
make_sourcedb_all_facet_sources.argument.append    = False

# expand the dir-indep sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           = plugin
expand_sourcedb_all_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     = make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       = expand_sourcedb_all_facet_sources.mapfile

# shift the empty data, add all facet sources, apply the direction-dependent solutions and average, length = nfiles or nbands_selfcal_facet_image * nchunks
# compress data and weights
prepare_imaging_data.control.type                                 = dppp
{% if preapply_phase_cal %}
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,expand_preapply_h5parm_map.output.mapfile,expand_combined_h5parm.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,sourcedb,pre_h5parm,h5parm]
{% else %}
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,expand_combined_h5parm.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,sourcedb,h5parm]
{% endif %}
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
prepare_imaging_data.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
prepare_imaging_data.argument.msin.startchan                      = {{ startchan_selfcal_facet_image }}
prepare_imaging_data.argument.msin.nchan                          = {{ nchan_selfcal_facet_image }}
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
{% if preapply_phase_cal %}
prepare_imaging_data.argument.steps                               = [shift,add,flag,correct_prefast1,correct_prefast2,correct_preslow,correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,add,flag,correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,flagzero,avg]
{% endif %}
{% else %}
{% if preapply_phase_cal %}
prepare_imaging_data.argument.steps                               = [shift,add,correct_prefast1,correct_prefast2,correct_preslow,correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,add,correct_fast1,correct_fast2,correct_slow_amp,correct_slow_phase,flagzero,avg]
{% endif %}
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ facet_ra }}deg, {{ facet_dec }}deg]
prepare_imaging_data.argument.add.type                            = predict
prepare_imaging_data.argument.add.sourcedb                        = sourcedb
prepare_imaging_data.argument.add.operation                       = add
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                           = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
{% if preapply_phase_cal %}
prepare_imaging_data.argument.correct_prefast1.type               = applycal
prepare_imaging_data.argument.correct_prefast1.parmdb             = pre_h5parm
prepare_imaging_data.argument.correct_prefast1.correction         = tec000
prepare_imaging_data.argument.correct_prefast1.invert             = True
prepare_imaging_data.argument.correct_prefast2.type               = applycal
prepare_imaging_data.argument.correct_prefast2.parmdb             = pre_h5parm
prepare_imaging_data.argument.correct_prefast2.correction         = phase000
prepare_imaging_data.argument.correct_prefast2.invert             = True
prepare_imaging_data.argument.correct_preslow.type                = applycal
prepare_imaging_data.argument.correct_preslow.parmdb              = pre_h5parm
prepare_imaging_data.argument.correct_preslow.correction          = phase001
prepare_imaging_data.argument.correct_preslow.invert              = True
{% endif %}
prepare_imaging_data.argument.correct_fast1.type                  = applycal
prepare_imaging_data.argument.correct_fast1.parmdb                = h5parm
prepare_imaging_data.argument.correct_fast1.correction            = tec000
prepare_imaging_data.argument.correct_fast1.invert                = True
prepare_imaging_data.argument.correct_fast2.type                  = applycal
prepare_imaging_data.argument.correct_fast2.parmdb                = h5parm
prepare_imaging_data.argument.correct_fast2.correction            = phase000
prepare_imaging_data.argument.correct_fast2.invert                = True
prepare_imaging_data.argument.correct_slow_amp.type               = applycal
prepare_imaging_data.argument.correct_slow_amp.parmdb             = h5parm
prepare_imaging_data.argument.correct_slow_amp.correction         = amplitude001
prepare_imaging_data.argument.correct_slow_amp.invert             = True
prepare_imaging_data.argument.correct_slow_phase.type             = applycal
prepare_imaging_data.argument.correct_slow_phase.parmdb           = h5parm
prepare_imaging_data.argument.correct_slow_phase.correction       = phase001
prepare_imaging_data.argument.correct_slow_phase.invert           = True
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = {{ facetimage_freqstep }}
prepare_imaging_data.argument.avg.timestep                        = {{ facetimage_timestep }}
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 16
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
# {% endif %}

{% if not is_patch %}
# Now make the high-res facet image

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind        = plugin
create_compressed_mapfile5.control.type        = compressMapfile
create_compressed_mapfile5.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile5.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile5.control.filename    = concat_averaged_input.mapfile

# make a facet clean mask from the last selfcal image, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_imagebase_map42.output.mapfile
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [create_compressed_mapfile5.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,{{ idg_arg }}msfile]
wsclean_image_full.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,{{ idg_arg }}msfile]
{% endif %}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_selfcal }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_selfcal_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full.argument.temp-dir              = {{ local_dir_parent }}
{% endif %}
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full.argument.multiscale-scales     = 0
wsclean_image_full.argument.weighting-rank-filter = 3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}
{% if use_idg %}
wsclean_image_full.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image_full.argument.auto-mask             = 3
wsclean_image_full.argument.auto-threshold        = 1.0
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind        = plugin
adjust_wsclean_mapfile1.control.type        = appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in  = create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename    = final_image1.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask5.control.type                = make_clean_mask
mask5.control.mapfile_in          = adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey            = imagefile
mask5.control.outputkey           = maskfile
mask5.argument.flags              = [imagefile,maskfile]
mask5.argument.region_file        = {{ region_field }}
mask5.argument.threshisl          = 6
mask5.argument.threshpix          = 8
mask5.argument.rmsbox             = (80,20)
mask5.argument.adaptive_rmsbox    = True
mask5.argument.atrous_do          = False
mask5.argument.img_format         = fits
mask5.argument.vertices_file      = {{ vertices_file }}
mask5.argument.exclude_cal_region = True
mask5.argument.dilate             = 2

# check the mask5 output and modify its mapfile if no sources were found, length = 1
check_mask_high.control.kind          = plugin
check_mask_high.control.type          = checkMapfile
check_mask_high.control.mapfile_in    = mask5.output.mapfile
check_mask_high.control.mapfile_check = mask5.output.threshold_5sig.mapfile
check_mask_high.control.mapfile_dir   = input.output.mapfile_dir
check_mask_high.control.filename      = check_mask5_map.mapfile

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model5_map.control.kind        = plugin
create_model5_map.control.type        = trimMapfile
create_model5_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-model.fits.mapfile
create_model5_map.control.trim        = -
create_model5_map.control.mapfile_dir = input.output.mapfile_dir
create_model5_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model5_map.control.kind             = plugin
expand_model5_map.control.type             = expandMapfile
expand_model5_map.control.mapfile_in       = create_model5_map.output.mapfile
expand_model5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model5_map.control.filename         = expand_model5_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask5_map.control.kind             = plugin
expand_mask5_map.control.type             = expandMapfile
expand_mask5_map.control.mapfile_in       = check_mask_high.output.mapfile
expand_mask5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask5_map.control.filename         = expand_mask5_map.mapfile

# make high-res full-facet sky model, using mask above, len = nbands
make_high_facet_skymodel.control.type        = poly2sky
make_high_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model5_map.output.mapfile,expand_mask5_map.output.mapfile]
make_high_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_high_facet_skymodel.control.outputkey   = skymodel
make_high_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

# combine the new calibrator and facet sky models, length = nbands
combine_skymodels_high.control.type        = combine_skymodels
combine_skymodels_high.control.mapfiles_in = [make_high_facet_skymodel.output.mapfile,make_new_cal_skymodel.output.mapfile]
combine_skymodels_high.control.inputkeys   = [newfacetmodel,calmodel]
combine_skymodels_high.control.outputkey   = skymodel
combine_skymodels_high.argument.flags      = [calmodel,newfacetmodel,skymodel]

# end of high-res full facet imaging
{% endif %}

# Make a medium-res image of the facet or (if mscale_selfcal_do is True)
# of the calibrator region to pick up any extended emission missed in the high-
# res image

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_high.control.type       = make_sourcedb
{% if is_patch %}
make_sourcedb_high.control.mapfile_in = make_new_cal_skymodel.output.mapfile
{% else %}
make_sourcedb_high.control.mapfile_in = combine_skymodels_high.output.mapfile
{% endif %}
make_sourcedb_high.control.inputkey   = in
make_sourcedb_high.argument.format    = <
make_sourcedb_high.argument.outtype   = blob
make_sourcedb_high.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_high.control.kind           = plugin
expand_sourcedb_high.control.type           = mapfileSingleToGroup
expand_sourcedb_high.control.mapfile_in     = make_sourcedb_high.output.mapfile
expand_sourcedb_high.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_high.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_high.control.filename       = expand_sourcedb_high.mapfile

# subtract the high-resolution model, length = nfiles or nbands_selfcal_facet_image * nchunks
# compress data and weights
subtract_high.control.type                                 = dppp
subtract_high.control.mapfiles_in                          = [prepare_imaging_data.output.mapfile,expand_sourcedb_high.output.mapfile]
subtract_high.control.inputkeys                            = [msin,sourcedb_high]
subtract_high.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
subtract_high.argument.msin.datacolumn                     = DATA
subtract_high.argument.msout.overwrite                     = True
subtract_high.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
subtract_high.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
subtract_high.argument.steps                               = [subtract,avg]
subtract_high.argument.subtract.type                       = predict
subtract_high.argument.subtract.sourcedb                   = sourcedb_high
subtract_high.argument.subtract.operation                  = subtract
subtract_high.argument.avg.type                            = squash
subtract_high.argument.avg.freqstep                        = {{ facetimage_low_freqstep }}
subtract_high.argument.avg.timestep                        = {{ facetimage_low_timestep }}
{% if use_compression %}
subtract_high.argument.msout.storagemanager                = "Dysco"
subtract_high.argument.msout.storagemanager.databitrate    = 0
subtract_high.argument.msout.storagemanager.weightbitrate  = 12
subtract_high.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
subtract_high.argument.msout.storagemanager.disttruncation = 1.5
subtract_high.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile6.control.kind        = plugin
create_compressed_mapfile6.control.type        = compressMapfile
create_compressed_mapfile6.control.mapfile_in  = subtract_high.output.mapfile
create_compressed_mapfile6.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile6.control.filename    = concat_averaged_med_input.mapfile

# Make a facet clean mask from the facet region, length = 1
premask_med.control.type                   = make_clean_mask
premask_med.control.mapfile_in             = create_compressed_mapfile6.output.mapfile
premask_med.control.inputkey               = imagefile
premask_med.control.outputkey              = maskfile
premask_med.argument.flags                 = [imagefile,maskfile]
premask_med.argument.img_format            = fits
premask_med.argument.pad_to_size           = {{ facet_med_imsize }}
premask_med.argument.skip_source_detection = True
premask_med.argument.vertices_file         = {{ vertices_file }}
premask_med.argument.reference_ra_deg      = {{ facet_ra }}
premask_med.argument.reference_dec_deg     = {{ facet_dec }}
premask_med.argument.cellsize_deg          = {{ cellsize_facet_med_deg }}
premask_med.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask at med resolution, length = 1
wsclean_image_full_med.control.type                   = wsclean
wsclean_image_full_med.control.mapfiles_in            = [create_compressed_mapfile6.output.mapfile,premask_med.output.mapfile]
wsclean_image_full_med.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,{{ idg_arg }}msfile]
wsclean_image_full_med.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,{{ idg_arg }}msfile]
{% endif %}
wsclean_image_full_med.argument.fitsmask              = fitsmask
wsclean_image_full_med.argument.size                  = {{ facet_med_imsize }} {{ facet_med_imsize }}
wsclean_image_full_med.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full_med.argument.pol                   = I
wsclean_image_full_med.argument.weight                = briggs 0.0
wsclean_image_full_med.argument.mgain                 = 0.8
wsclean_image_full_med.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full_med.argument.taper-gaussian        = {{ cellsize_facet_med_deg*3600*3 }}arcsec
wsclean_image_full_med.argument.scale                 = {{ cellsize_facet_med_deg }}
wsclean_image_full_med.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full_med.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full_med.argument.temp-dir              = {{ local_dir_parent }}
{% endif %}
wsclean_image_full_med.argument.multiscale-shape      = gaussian
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full_med.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full_med.argument.weighting-rank-filter = 3
{% if facetimage_medlow_wsclean_nwavelengths > 0.0 %}
wsclean_image_full_med.argument.baseline-averaging    = {{ facetimage_medlow_wsclean_nwavelengths }}
{% endif %}
{% if use_idg %}
wsclean_image_full_med.argument.idg-mode               = {{ idg_mode }}
{% endif %}
wsclean_image_full_med.argument.auto-mask             = 3
wsclean_image_full_med.argument.auto-threshold        = 0.5
wsclean_image_full_med.argument.local-rms-window      = 50
wsclean_image_full_med.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_med_map.control.kind        = plugin
create_imagebase_med_map.control.type        = trimMapfile
create_imagebase_med_map.control.mapfile_in  = wsclean_image_full_med.output.wsclean_image_full_med-image.fits.mapfile
create_imagebase_med_map.control.trim        = -
create_imagebase_med_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_med_map.control.filename    = wsclean_image_full_med_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile3.control.kind        = plugin
adjust_wsclean_mapfile3.control.type        = appendMapfile
adjust_wsclean_mapfile3.control.mapfile_in  = create_imagebase_med_map.output.mapfile
adjust_wsclean_mapfile3.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile3.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile3.control.filename    = final_image_med.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask6.control.type                = make_clean_mask
mask6.control.mapfile_in          = adjust_wsclean_mapfile3.output.mapfile
mask6.control.inputkey            = imagefile
mask6.control.outputkey           = maskfile
mask6.argument.flags              = [imagefile,maskfile]
mask6.argument.region_file        = {{ region_field }}
mask6.argument.threshisl          = 5
mask6.argument.threshpix          = 8
mask6.argument.rmsbox             = (80,20)
mask6.argument.adaptive_rmsbox    = True
mask6.argument.atrous_do          = True
mask6.argument.img_format         = fits
mask6.argument.vertices_file      = {{ vertices_file }}
mask6.argument.exclude_cal_region = False
mask6.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_med.control.kind          = plugin
check_mask_med.control.type          = checkMapfile
check_mask_med.control.mapfile_in    = mask6.output.mapfile
check_mask_med.control.mapfile_check = mask6.output.threshold_5sig.mapfile
check_mask_med.control.mapfile_dir   = input.output.mapfile_dir
check_mask_med.control.filename      = check_mask6_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model6_map.control.kind             = plugin
expand_model6_map.control.type             = expandMapfile
expand_model6_map.control.mapfile_in       = create_imagebase_med_map.output.mapfile
expand_model6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model6_map.control.filename         = expand_model6_map.mapfile

# expand the mask mapfile so that there is one entry for every band, length = nbands
expand_mask6_map.control.kind             = plugin
expand_mask6_map.control.type             = expandMapfile
expand_mask6_map.control.mapfile_in       = check_mask_med.output.mapfile
expand_mask6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask6_map.control.filename         = expand_mask6_map.mapfile

# make med-res full-facet sky model, using mask above, len = nbands
make_med_facet_skymodel.control.type        = poly2sky
make_med_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model6_map.output.mapfile,expand_mask6_map.output.mapfile]
make_med_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_med_facet_skymodel.control.outputkey   = skymodel
make_med_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask,0.0,0.0]

# combine the medium- and high-res facet sky models, length = nbands
combine_facet_skymodels.control.type        = combine_skymodels
{% if is_patch %}
combine_facet_skymodels.control.mapfiles_in = [make_new_cal_skymodel.output.mapfile,make_med_facet_skymodel.output.mapfile]
{% else %}
combine_facet_skymodels.control.mapfiles_in = [combine_skymodels_high.output.mapfile,make_med_facet_skymodel.output.mapfile]
{% endif %}
combine_facet_skymodels.control.inputkeys   = [highresmodel,medresmodel]
combine_facet_skymodels.control.outputkey   = skymodel
combine_facet_skymodels.argument.flags      = [highresmodel,medresmodel,skymodel]

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = combine_facet_skymodels.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob
make_sourcedb_new_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% else %}
# for patches for which mscale_selfcal_do = False, just make a sourcedb
# from the new calibrator sky model

# convert the calibrator sky model (= facet sky model) into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = make_new_cal_skymodel.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob
make_sourcedb_new_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" block

# predict the old and new models and subtract the old one from the new one, length = nfiles
# compress weights only
predict_and_difference_models.control.type                                     = dppp
{% if not is_patch %}
{% if preapply_phase_cal %}
predict_and_difference_models.control.mapfiles_in                              = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_preapply_h5parm_map.output.mapfile,expand_combined_h5parm.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                                = [msin,dir_dep_sourcedb,pre_h5parm,dir_dep_h5parm,dir_indep_sourcedb]
{% else %}
predict_and_difference_models.control.mapfiles_in                              = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_combined_h5parm.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                                = [msin,dir_dep_sourcedb,dir_dep_h5parm,dir_indep_sourcedb]
{% endif %}
{% else %}
{% if preapply_phase_cal %}
predict_and_difference_models.control.mapfiles_in                              = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_preapply_h5parm_map.output.mapfile,expand_combined_h5parm.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                                = [msin,dir_dep_sourcedb,pre_h5parm,dir_dep_h5parm,dir_indep_sourcedb]
{% else %}
predict_and_difference_models.control.mapfiles_in                              = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_combined_h5parm.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                                = [msin,dir_dep_sourcedb,dir_dep_h5parm,dir_indep_sourcedb]
{% endif %}
{% endif %}
predict_and_difference_models.argument.numthreads                              = {{ max_cpus_per_io_proc_nfiles }}
predict_and_difference_models.argument.msin.datacolumn                         = DATA
predict_and_difference_models.argument.msout.overwrite                         = True
predict_and_difference_models.argument.msout.writefullresflag                  = False
{% if local_dir is not none %}
predict_and_difference_models.argument.local_scratch_dir                       = {{ local_dir }}
{% endif %}
predict_and_difference_models.argument.steps                                   = [pred_new,subtract_old]
predict_and_difference_models.argument.pred_new.type                           = predict
predict_and_difference_models.argument.pred_new.sourcedb                       = dir_dep_sourcedb
{% if preapply_phase_cal %}
predict_and_difference_models.argument.pred_new.applycal.steps                 = [prefast1,prefast2,preslow,fast1,fast2,slow_amp,slow_phase]
{% else %}
predict_and_difference_models.argument.pred_new.applycal.steps                 = [fast1,fast2,slow_amp,slow_phase]
{% endif %}
{% if preapply_phase_cal %}
predict_and_difference_models.argument.pred_new.applycal.prefast1.parmdb       = pre_h5parm
predict_and_difference_models.argument.pred_new.applycal.prefast1.correction   = tec000
predict_and_difference_models.argument.pred_new.applycal.prefast2.parmdb       = pre_h5parm
predict_and_difference_models.argument.pred_new.applycal.prefast2.correction   = phase000
predict_and_difference_models.argument.pred_new.applycal.preslow.parmdb        = pre_h5parm
predict_and_difference_models.argument.pred_new.applycal.preslow.correction    = phase001
{% endif %}
predict_and_difference_models.argument.pred_new.applycal.fast1.parmdb          = dir_dep_h5parm
predict_and_difference_models.argument.pred_new.applycal.fast1.correction      = tec000
predict_and_difference_models.argument.pred_new.applycal.fast2.parmdb          = dir_dep_h5parm
predict_and_difference_models.argument.pred_new.applycal.fast2.correction      = phase000
predict_and_difference_models.argument.pred_new.applycal.slow_amp.parmdb       = dir_dep_h5parm
predict_and_difference_models.argument.pred_new.applycal.slow_amp.correction   = amplitude001
predict_and_difference_models.argument.pred_new.applycal.slow_phase.parmdb     = dir_dep_h5parm
predict_and_difference_models.argument.pred_new.applycal.slow_phase.correction = phase001
predict_and_difference_models.argument.pred_new.operation                      = replace
predict_and_difference_models.argument.subtract_old.type                       = predict
predict_and_difference_models.argument.subtract_old.sourcedb                   = dir_indep_sourcedb
predict_and_difference_models.argument.subtract_old.operation                  = subtract
{% if use_compression %}
predict_and_difference_models.argument.msout.storagemanager                    = "Dysco"
predict_and_difference_models.argument.msout.storagemanager.databitrate        = 0
predict_and_difference_models.argument.msout.storagemanager.weightbitrate      = 12
predict_and_difference_models.argument.msout.storagemanager.distribution       = "TruncatedGaussian"
predict_and_difference_models.argument.msout.storagemanager.disttruncation     = 1.5
predict_and_difference_models.argument.msout.storagemanager.normalization      = "AF"
{% endif %}

#
# Verify the quality of selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile1.control.kind        = plugin
create_middle_band_mapfile1.control.type        = selectMiddleFreq
create_middle_band_mapfile1.control.mapfile_in  = create_ms_map.output.mapfile
create_middle_band_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile1.control.filename    = single_band_orig.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile2.control.kind        = plugin
create_middle_band_mapfile2.control.type        = selectMiddleFreq
create_middle_band_mapfile2.control.mapfile_in  = predict_and_difference_models.output.mapfile
create_middle_band_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile2.control.filename    = single_band_new.mapfile

# subtract new facet data from original data, length = ntimes
subtract_single.control.type        = add_subtract_columns
subtract_single.control.mapfiles_in = [create_middle_band_mapfile2.output.mapfile,create_middle_band_mapfile1.output.mapfile]
subtract_single.control.inputkeys   = [file1,file2]
subtract_single.argument.flags      = [file1,file2,DATA,{{ subtracted_data_colname }},MODEL_DATA,subtract21]

# average old empty data, length = ntimes
average_pre.control.type                                 = dppp
average_pre.control.mapfile_in                           = create_middle_band_mapfile1.output.mapfile
average_pre.control.inputkey                             = msin
average_pre.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
average_pre.argument.msout.overwrite                     = True
average_pre.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_pre.argument.steps                               = [uv,avg]
average_pre.argument.uv.type                             = uvwflagger
average_pre.argument.uv.uvmmax                           = 2500.0
average_pre.argument.avg.type                            = squash
average_pre.argument.avg.freqstep                        = {{ verify_freqstep }}
average_pre.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                = "Dysco"
average_pre.argument.msout.storagemanager.databitrate    = 16
average_pre.argument.msout.storagemanager.weightbitrate  = 12
average_pre.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation = 1.5
average_pre.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                 = dppp
average_post.control.mapfile_in                           = create_middle_band_mapfile2.output.mapfile
average_post.control.inputkey                             = msin
average_post.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                     = MODEL_DATA
average_post.argument.msout.overwrite                     = True
average_post.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_post.argument.steps                               = [uv,avg]
average_post.argument.uv.type                             = uvwflagger
average_post.argument.uv.uvmmax                           = 2500.0
average_post.argument.avg.type                            = squash
average_post.argument.avg.freqstep                        = {{ verify_freqstep }}
average_post.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                = "Dysco"
average_post.argument.msout.storagemanager.databitrate    = 16
average_post.argument.msout.storagemanager.weightbitrate  = 12
average_post.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation = 1.5
average_post.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind        = plugin
average_pre_compressed_map.control.type        = compressMapfile
average_pre_compressed_map.control.mapfile_in  = average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_pre_compressed_map.control.filename    = average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type         = wsclean
wsclean_pre.control.mapfile_in   = average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey     = msfiles
wsclean_pre.argument.flags       = [-no-update-model-required,msfiles]
wsclean_pre.argument.size        = 2048 2048
wsclean_pre.argument.niter       = 10
wsclean_pre.argument.threshold   = 0.0
wsclean_pre.argument.pol         = I
wsclean_pre.argument.weight      = briggs -0.5
wsclean_pre.argument.mgain       = 0.8
wsclean_pre.argument.gain        = 0.1
wsclean_pre.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l     = 2500
wsclean_pre.argument.scale       = 0.00833
wsclean_pre.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.temp-dir    = {{ local_dir_parent }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind        = plugin
average_post_compressed_map.control.type        = compressMapfile
average_post_compressed_map.control.mapfile_in  = average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_post_compressed_map.control.filename    = average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type         = wsclean
wsclean_post.control.mapfile_in   = average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey     = msfiles
wsclean_post.argument.flags       = [-no-update-model-required,msfiles]
wsclean_post.argument.size        = 2048 2048
wsclean_post.argument.niter       = 10
wsclean_post.argument.threshold   = 0.0
wsclean_post.argument.pol         = I
wsclean_post.argument.weight      = briggs -0.5
wsclean_post.argument.mgain       = 0.8
wsclean_post.argument.gain        = 0.1
wsclean_post.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l     = 2500
wsclean_post.argument.scale       = 0.00833
wsclean_post.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.temp-dir    = {{ local_dir_parent }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type        = verify_subtract
verify_subtract.control.mapfiles_in = [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys   = [image_pre,image_post]
verify_subtract.argument.flags      = [image_pre,image_post,0.75]
