pipeline.steps = [update_mapfile_hosts, {% if use_existing_data %} update_image_data_mapfile_hosts, {% if average_image_data %} concat_averaged_uncompressed_map, average_image_data, concat_reaveraged_compressed_map, {% endif %} {% else %} create_ms_map, create_msmulti_map, expand_merged_parmdb_map, shift_empty, add_imaging_cols, regroup_shift_empty_map, {% block model_data_steps %}expand_facet_model_map, expand_facet_model_size_map, wsclean_ft, {% endblock model_data_steps %} corrupt_final_model, add_model_to_empty_data, apply_dir_dep, create_compressed_mapfile, sort_into_Groups, sort_into_Groups_maps, concat_averaged, concat_averaged_compressed_map, {% endif %} {% block full_image_steps %}premask, wsclean_image_full1, create_imagebase_map1, adjust_wsclean_mapfile1, mask, wsclean_image_full2, create_imagebase_map2, adjust_wsclean_mapfile2{% endblock full_image_steps %}]

pipeline.pluginpath                               =   {{ pipeline_dir }}/plugins

# update host entries in all mapfiles
update_mapfile_hosts.control.kind                     =   plugin
update_mapfile_hosts.control.type                     =   updateHosts
update_mapfile_hosts.control.mapfile_dir              =   input.output.mapfile_dir
update_mapfile_hosts.control.hosts                    =   {{ hosts }}

{% if use_existing_data %}
# update host entries in existing image_data_mapfile
update_image_data_mapfile_hosts.control.kind          =   plugin
update_image_data_mapfile_hosts.control.type          =   updateHosts
update_image_data_mapfile_hosts.control.mapfile_in    =   {{ image_data_mapfile }}
update_image_data_mapfile_hosts.control.hosts         =   {{ hosts }}

{% if average_image_data %}
# make an uncompressed mapfile of the concatenated data, length = 1
concat_averaged_uncompressed_map.control.kind         =   plugin
concat_averaged_uncompressed_map.control.type         =   uncompressMapfile
concat_averaged_uncompressed_map.control.mapfile_in   =   {{ image_data_mapfile }}
concat_averaged_uncompressed_map.control.mapfile_dir  =   input.output.mapfile_dir
concat_averaged_uncompressed_map.control.hosts        =   {{ hosts }}
concat_averaged_uncompressed_map.control.filename     =   concat_averaged_uncompressed.mapfile

# average if necessary
average_image_data.control.type                       =   dppp
average_image_data.control.mapfile_in                 =   concat_averaged_uncompressed_map.output.mapfile
average_image_data.control.inputkey                   =   msin
average_image_data.argument.numthreads                =   {{ max_cpus_per_band }}
average_image_data.argument.msin.datacolumn           =   DATA
average_image_data.argument.msout.overwrite           =   True
average_image_data.argument.msout.writefullresflag    =   False
average_image_data.argument.local_scratch_dir         =   {{ local_dir }}
average_image_data.argument.steps                     =   [avg]
average_image_data.argument.avg.type                  =   squash
average_image_data.argument.avg.freqstep              =   {{ facetimage_freqstep }}
average_image_data.argument.avg.timestep              =   {{ facetimage_timestep }}

# make a compressed mapfile of the reaveraged data, length = 1
concat_reaveraged_compressed_map.control.kind         =   plugin
concat_reaveraged_compressed_map.control.type         =   compressMapfile
concat_reaveraged_compressed_map.control.mapfile_in   =   average_image_data.output.mapfile
concat_reaveraged_compressed_map.control.mapfile_dir  =   input.output.mapfile_dir
concat_reaveraged_compressed_map.control.filename     =   concat_reaveraged_compressed.mapfile
{% endif %}

{% else %}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind                            =   plugin
create_ms_map.control.type                            =   addListMapfile
create_ms_map.control.hosts                           =   {{ hosts }}
create_ms_map.control.files                           =   {{ ms_files_single }}
create_ms_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_ms_map.control.filename                        =   input_bands.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind                       =   plugin
create_msmulti_map.control.type                       =   addListMultiMapfile
create_msmulti_map.control.hosts                      =   {{ hosts }}
create_msmulti_map.control.files                      =   {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir                =   input.output.mapfile_dir
create_msmulti_map.control.filename                   =   input_files_grouped.mapfile

# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind                 =   plugin
expand_merged_parmdb_map.control.type                 =   expandMapfile
expand_merged_parmdb_map.control.mapfile_in           =   {{ dir_dep_parmdb_mapfile }}
expand_merged_parmdb_map.control.mapfile_to_match     =   create_ms_map.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir          =   input.output.mapfile_dir
expand_merged_parmdb_map.control.filename             =   expand_merged_parmdbs.mapfile

# shift current residual visibilities to facet-center, length = nfiles
shift_empty.control.type                              =   dppp
shift_empty.control.opts.mapfile_in                   =   create_ms_map.output.mapfile
shift_empty.control.opts.inputkey                     =   msin
shift_empty.control.opts.inputkey                     =   msin
shift_empty.argument.numthreads                       =   {{ max_cpus_per_band }}
shift_empty.argument.msin.datacolumn                  =   SUBTRACTED_DATA_ALL_NEW
shift_empty.argument.msout.overwrite                  =   True
shift_empty.argument.msout.writefullresflag           =   False
shift_empty.argument.local_scratch_dir                =   {{ local_dir }}
shift_empty.argument.steps                            =   [shift]
shift_empty.argument.shift.type                       =   phaseshifter
shift_empty.argument.shift.phasecenter                =   [{{ facet_ra }}deg, {{ facet_dec }}deg]

# add the imaging columns to the MS files, length = nfiles
add_imaging_cols.control.type                         =   add_imaging_columns
add_imaging_cols.control.mapfile_in                   =   shift_empty.output.mapfile
add_imaging_cols.control.inputkey                     =   msfile
add_imaging_cols.argument.flags                       =   [msfile]

# sort the "shift_empty" unaveraged data into groups that can be concatenated, length = some
# needed because virtual concatenating all files results in a "too many open files" error.
regroup_shift_empty_map.control.kind                  =   plugin
regroup_shift_empty_map.control.type                  =   reGroupMapfile
regroup_shift_empty_map.control.mapfile_in            =   shift_empty.output.mapfile
regroup_shift_empty_map.control.mapfile_groups        =   create_msmulti_map.output.mapfile
regroup_shift_empty_map.control.mapfile_dir           =   input.output.mapfile_dir
regroup_shift_empty_map.control.join_max_files        =   100
regroup_shift_empty_map.control.rotate_groups         =   True
regroup_shift_empty_map.control.filename              =   regroup_shift_empty.mapfile

{% block model_data_parms %}
# expand mapfile of the facet-model to all groups, length = some
expand_facet_model_map.control.kind                   =   plugin
expand_facet_model_map.control.type                   =   expandMapfile
expand_facet_model_map.control.mapfile_in             =   {{ facet_model_mapfile }}
expand_facet_model_map.control.mapfile_to_match       =   regroup_shift_empty_map.output.mapfile
expand_facet_model_map.control.mapfile_dir            =   input.output.mapfile_dir
expand_facet_model_map.control.filename               =   expand_facet_model.mapfile

# expand mapfile of the model image sizes to all groups, length = some
expand_facet_model_size_map.control.kind              =   plugin
expand_facet_model_size_map.control.type              =   expandMapfile
expand_facet_model_size_map.control.mapfile_in        =   {{ wsclean_modelimg_size_mapfile }}
expand_facet_model_size_map.control.mapfile_to_match  =   regroup_shift_empty_map.output.mapfile
expand_facet_model_size_map.control.mapfile_dir       =   input.output.mapfile_dir
expand_facet_model_size_map.control.filename          =   expand_facet_model_size.mapfile

# add the facet-model visibilities to the data, length = some
# For WSClean predict, we do not need to increase the number of wplanes (as is
# done for the predict step used for subtraction), as we do not care about
# regions outside of the facet image
wsclean_ft.control.type                               =   wsclean_ft
wsclean_ft.control.mapfiles_in                        =   [regroup_shift_empty_map.output.mapfile,expand_facet_model_map.output.mapfile,expand_facet_model_size_map.output.mapfile]
wsclean_ft.control.inputkeys                          =   [msfile,name,size]
wsclean_ft.argument.flags                             =   [-predict,msfile]
wsclean_ft.argument.scale                             =   0.000417
wsclean_ft.argument.mem                               =   {{ max_percent_memory }}
wsclean_ft.argument.channelsout                       =   {{ wsclean_nchannels }}
wsclean_ft.argument.j                                 =   {{ max_cpus_per_node }}
wsclean_ft.argument.tempdir                           =   {{ local_dir }}
{% endblock model_data_parms %}

# corrupt the facet-model visibilities, length = nfiles
corrupt_final_model.control.type                      =   dppp
corrupt_final_model.control.opts.mapfiles_in          =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
corrupt_final_model.control.opts.inputkeys            =   [msin,parmdb]
corrupt_final_model.argument.numthreads               =   {{ max_cpus_per_band }}
corrupt_final_model.argument.msin.datacolumn          =   MODEL_DATA
corrupt_final_model.argument.msout.overwrite          =   True
corrupt_final_model.argument.msout.writefullresflag   =   False
corrupt_final_model.argument.local_scratch_dir        =   {{ local_dir }}
corrupt_final_model.argument.steps                    =   [corrupt_fast1,corrupt_fast2,corrupt_slow]
corrupt_final_model.argument.corrupt_fast1.type       =   applycal
corrupt_final_model.argument.corrupt_fast1.parmdb     =   parmdb
corrupt_final_model.argument.corrupt_fast1.correction =   tec
corrupt_final_model.argument.corrupt_fast1.invert     =   False
corrupt_final_model.argument.corrupt_fast2.type       =   applycal
corrupt_final_model.argument.corrupt_fast2.parmdb     =   parmdb
corrupt_final_model.argument.corrupt_fast2.correction =   commonscalarphase
corrupt_final_model.argument.corrupt_fast2.invert     =   False
corrupt_final_model.argument.corrupt_slow.type        =   applycal
corrupt_final_model.argument.corrupt_slow.parmdb      =   parmdb
corrupt_final_model.argument.corrupt_slow.invert      =   False

# add the facet-model visibilities to the data, length = nfiles
add_model_to_empty_data.control.type                  =   add_subtract_columns
add_model_to_empty_data.control.opts.mapfiles_in      =   [shift_empty.output.mapfile,corrupt_final_model.output.mapfile]
add_model_to_empty_data.control.opts.inputkeys        =   [file1,file2]
add_model_to_empty_data.argument.flags                =   [file1,file2,DATA,DATA,FACET_DATA_ALL,add]

# apply the direction-dependent solutions and average, length = nfiles
apply_dir_dep.control.type                                 =   dppp
apply_dir_dep.control.opts.mapfiles_in                     =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
apply_dir_dep.control.opts.inputkeys                       =   [msin,dir_dep_parmdb]
apply_dir_dep.argument.numthreads                          =   {{ max_cpus_per_chunk }}
apply_dir_dep.argument.msin.datacolumn                     =   FACET_DATA_ALL
apply_dir_dep.argument.msout.overwrite                     =   True
apply_dir_dep.argument.msout.writefullresflag              =   False
apply_dir_dep.argument.local_scratch_dir                   =   {{ local_dir }}
apply_dir_dep.argument.steps                               =   [correct_fast1,correct_fast2,correct_slow,flagzero,avg]
apply_dir_dep.argument.correct_fast1.type                  =   applycal
apply_dir_dep.argument.correct_fast1.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast1.correction            =   tec
apply_dir_dep.argument.correct_fast1.invert                =   True
apply_dir_dep.argument.correct_fast2.type                  =   applycal
apply_dir_dep.argument.correct_fast2.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast2.correction            =   commonscalarphase
apply_dir_dep.argument.correct_fast2.invert                =   True
apply_dir_dep.argument.correct_slow.type                   =   applycal
apply_dir_dep.argument.correct_slow.parmdb                 =   dir_dep_parmdb
apply_dir_dep.argument.correct_slow.invert                 =   True
apply_dir_dep.argument.flagzero.type                       =   preflagger
apply_dir_dep.argument.flagzero.amplmin                    =   1e-20
apply_dir_dep.argument.avg.type                            =   squash
apply_dir_dep.argument.avg.freqstep                        =   {{ facetimage_freqstep }}
apply_dir_dep.argument.avg.timestep                        =   {{ facetimage_timestep }}

# make the compressed mapfile, length = 1
create_compressed_mapfile.control.kind                =   plugin
create_compressed_mapfile.control.type                =   compressMapfile
create_compressed_mapfile.control.mapfile_in          =   apply_dir_dep.output.mapfile
create_compressed_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_compressed_mapfile.control.filename            =   concat_averaged_input.mapfile

#############################
# need to test: is it faster to first concatenate, or to have WSClean run on hundreds of small files?
# Same for Casa!
#############################
# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_into_Groups.control.type                         =   sort_times_into_freqGroups
sort_into_Groups.argument.flags                       =   [create_compressed_mapfile.output.mapfile]
sort_into_Groups.argument.filename                    =   sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir                 =   input.output.mapfile_dir
sort_into_Groups.argument.hosts                       =   {{ hosts }}
sort_into_Groups.argument.nband_pad                   =   {{ nband_pad }}

# convert the output of sort_into_Groups into usable mapfiles, len = ntimes
sort_into_Groups_maps.control.kind                    =   plugin
sort_into_Groups_maps.control.type                    =   mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap        =   sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap        =   sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes
concat_averaged.control.type                          =   dppp
concat_averaged.control.mapfile_out                   =   sort_into_Groups_maps.output.groupmap
concat_averaged.control.mapfile_in                    =   sort_into_Groups_maps.output.filesmap
concat_averaged.control.inputkey                      =   msin
concat_averaged.argument.msin.datacolumn              =   DATA
concat_averaged.argument.msin.missingdata             =   True
concat_averaged.argument.msin.orderms                 =   False
concat_averaged.argument.msout.overwrite              =   True
concat_averaged.argument.msout.writefullresflag       =   False
concat_averaged.argument.local_scratch_dir            =   {{ local_dir }}
concat_averaged.argument.steps                        =   []

# make a compressed mapfile of the concatenated data, length = 1
concat_averaged_compressed_map.control.kind           =   plugin
concat_averaged_compressed_map.control.type           =   compressMapfile
concat_averaged_compressed_map.control.mapfile_in     =   concat_averaged.output.mapfile
concat_averaged_compressed_map.control.mapfile_dir    =   input.output.mapfile_dir
concat_averaged_compressed_map.control.filename       =   concat_averaged_compressed.mapfile
{% endif %}

{% block full_image_parms %}

# Make a preliminary clean mask from the facet region, length = 1
premask.control.type                                    =   make_clean_mask
premask.control.mapfile_in                              =   {{ image_data_mapfile }}
premask.control.inputkey                                =   imagefile
premask.control.outputkey                               =   maskfile
premask.argument.flags                                  =   [imagefile,maskfile]
premask.argument.img_format                             =   fits
premask.argument.pad_to_size                            =   {{ facet_imsize }}
premask.argument.skip_source_detection                  =   True
premask.argument.vertices_file                          =   {{ vertices_file }}
premask.argument.reference_ra_deg                       =   {{ facet_ra }}
premask.argument.reference_dec_deg                      =   {{ facet_dec }}
premask.argument.cellsize_deg                           =   {{ cellsize_facet_deg }}

# do the first round of imaging, length = 1
wsclean_image_full1.control.type                      =   wsclean
{% if average_image_data %}
wsclean_image_full1.control.mapfiles_in               =   [concat_reaveraged_compressed_map.output.mapfile,premask.output.mapfile]
{% else %}
wsclean_image_full1.control.mapfiles_in               =   [{{ image_data_mapfile }},premask.output.mapfile]
{% endif %}
wsclean_image_full1.control.inputkeys                 =   [msfile,fitsmask]
wsclean_image_full1.argument.flags                    =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full1.argument.fitsmask                 =   fitsmask
wsclean_image_full1.argument.size                     =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full1.argument.niter                    =   {{ wsclean_full1_image_niter }}
wsclean_image_full1.argument.threshold                =   {{ wsclean_full1_image_threshold_jy }}
wsclean_image_full1.argument.pol                      =   I
wsclean_image_full1.argument.weight                   =   briggs {{ robust_facet }}
wsclean_image_full1.argument.mgain                    =   0.6
wsclean_image_full1.argument.cleanborder              =   0
wsclean_image_full1.argument.minuv-l                  =   {{ facet_min_uv_lambda }}
wsclean_image_full1.argument.scale                    =   {{ cellsize_facet_deg }}
wsclean_image_full1.argument.channelsout              =   {{ wsclean_nchannels }}
wsclean_image_full1.argument.mem                      =   {{ max_percent_memory }}
wsclean_image_full1.argument.j                        =   {{ max_cpus_per_node }}
wsclean_image_full1.argument.tempdir                  =   {{ local_dir }}
wsclean_image_full1.argument.weighting-rank-filter    =   3
{% if taper_facet_arcsec > 0.0 %}
wsclean_image_full1.argument.taper-gaussian           =  {{ taper_facet_arcsec }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map1.control.kind                    =   plugin
create_imagebase_map1.control.type                    =   trimMapfile
create_imagebase_map1.control.mapfile_in              =   wsclean_image_full1.output.wsclean_image_full1-image.fits.mapfile
create_imagebase_map1.control.trim                    =   -
create_imagebase_map1.control.mapfile_dir             =   input.output.mapfile_dir
create_imagebase_map1.control.filename                =   wsclean_image_full1_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind                  =   plugin
adjust_wsclean_mapfile1.control.type                  =   appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in            =   create_imagebase_map1.output.mapfile
adjust_wsclean_mapfile1.control.append                =   {{ wsclean_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir           =   input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename              =   image1.mapfile

# make a mask from the image, length = 1
mask.control.type                                     =   make_clean_mask
mask.control.mapfile_in                               =   adjust_wsclean_mapfile1.output.mapfile
mask.control.inputkey                                 =   imagefile
mask.control.outputkey                                =   maskfile
mask.argument.flags                                   =   [imagefile,maskfile]
mask.argument.region_file                             =   {{ region_field }}
mask.argument.threshisl                               =   3
mask.argument.threshpix                               =   5
mask.argument.rmsbox                                  =   (300,100)
mask.argument.rmsbox_bright                           =   (70,10)
mask.argument.atrous_jmax                             =   3
mask.argument.adaptive_rmsbox                         =   True
mask.argument.atrous_do                               =   True
mask.argument.img_format                              =   fits
mask.argument.vertices_file                           =   {{ vertices_file }}

# second round of imaging with the mask, length = 1
wsclean_image_full2.control.type                      =   wsclean
{% if average_image_data %}
wsclean_image_full2.control.mapfiles_in               =   [concat_reaveraged_compressed_map.output.mapfile,mask.output.mapfile,mask.output.threshold_5sig.mapfile]
{% else %}
wsclean_image_full2.control.mapfiles_in               =   [{{ image_data_mapfile }},mask.output.mapfile,mask.output.threshold_5sig.mapfile]
{% endif %}
wsclean_image_full2.control.inputkeys                 =   [msfile,fitsmask,threshold]
wsclean_image_full2.argument.flags                    =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full2.argument.fitsmask                 =   fitsmask
wsclean_image_full2.argument.size                     =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full2.argument.niter                    =   {{ wsclean_full2_image_niter }}
wsclean_image_full2.argument.threshold                =   threshold
wsclean_image_full2.argument.pol                      =   I
wsclean_image_full2.argument.weight                   =   briggs {{ robust_facet }}
wsclean_image_full2.argument.mgain                    =   0.6
wsclean_image_full2.argument.cleanborder              =   0
wsclean_image_full2.argument.minuv-l                  =   {{ facet_min_uv_lambda }}
wsclean_image_full2.argument.scale                    =   {{ cellsize_facet_deg }}
wsclean_image_full2.argument.channelsout              =   {{ wsclean_nchannels }}
wsclean_image_full2.argument.mem                      =   {{ max_percent_memory }}
wsclean_image_full2.argument.j                        =   {{ max_cpus_per_node }}
wsclean_image_full2.argument.tempdir                  =   {{ local_dir }}
wsclean_image_full2.argument.weighting-rank-filter    =   3
{% if taper_facet_arcsec > 0.0 %}
wsclean_image_full2.argument.taper-gaussian           =  {{ taper_facet_arcsec }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map2.control.kind                    =   plugin
create_imagebase_map2.control.type                    =   trimMapfile
create_imagebase_map2.control.mapfile_in              =   wsclean_image_full2.output.wsclean_image_full2-image.fits.mapfile
create_imagebase_map2.control.trim                    =   -
create_imagebase_map2.control.mapfile_dir             =   input.output.mapfile_dir
create_imagebase_map2.control.filename                =   wsclean_image_full2_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image at a known name, length = 1
adjust_wsclean_mapfile2.control.kind                  =   plugin
adjust_wsclean_mapfile2.control.type                  =   appendMapfile
adjust_wsclean_mapfile2.control.mapfile_in            =   create_imagebase_map2.output.mapfile
adjust_wsclean_mapfile2.control.append                =   {{ wsclean_suffix }}
adjust_wsclean_mapfile2.control.mapfile_dir           =   input.output.mapfile_dir
adjust_wsclean_mapfile2.control.filename              =   final_image.mapfile
{% endblock full_image_parms %}
