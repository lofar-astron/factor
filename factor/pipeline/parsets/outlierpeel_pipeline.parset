pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_full_skymodels_map, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, shift_cal, create_compressed_mapfile, sort_into_Groups, sort_into_Groups_maps, concat_data, concat_data_compressed_mapfile, {% if selfcal_local_dir is not none %} make_concat_data_sync_mapfile, sync_concat_data_to_local, {% endif %} make_fast_phase_h5parm_map, create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, remove_h5parms1, solve_ampphase11, apply_ampphase11, create_compressed_mapfile_fast, create_combined_fast_output_map, match_host_fast, merge_phase_h5parms, make_slow_gain_h5parm_map, remove_h5parms12, solve_ampphase12, create_compressed_mapfile_slow, create_combined_slow_output_map, match_host_slow, combine_slow_gains1, smooth_amps, smooth_amps_normalized, {% if selfcal_local_dir is not none %} remove_concat_data, {% endif %} create_combined_norm_output_map, create_combined_unnorm_output_map, combine_normalized_h5parms, combine_unnormalized_h5parms, {% if create_preapply_h5parm %} create_preapply_h5parm, {% endif %} make_selfcal_plots, expand_unnormalized_merged_h5parm_map, expand_normalized_merged_h5parm_map, expand_cal_sourcedb_map, {% if not is_patch %} make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, prepare_imaging_data, create_compressed_mapfile5, premask, wsclean_image_full, create_imagebase_map, adjust_wsclean_mapfile1, mask5, check_mask_high, create_model5_map, expand_model5_map, expand_mask5_map, make_high_facet_skymodel, make_sourcedb_high, expand_sourcedb_high, subtract_high, create_compressed_mapfile6, premask_med, wsclean_image_full_med, create_imagebase_med_map, adjust_wsclean_mapfile3, mask6, check_mask_med, expand_model6_map, expand_mask6_map, make_med_facet_skymodel, combine_facet_skymodels, make_sourcedb_new_facet_sources_for_facet_imaging, expand_sourcedb_new_facet_sources, {% endif %} predict_and_difference_models, create_middle_band_mapfile1, create_middle_band_mapfile2, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind        = plugin
create_full_skymodels_map.control.type        = addListMapfile
create_full_skymodels_map.control.hosts       = {{ hosts }}
create_full_skymodels_map.control.files       = {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir = input.output.mapfile_dir
create_full_skymodels_map.control.filename    = full_skymodels.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type       = make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey   = fullmodelfile
make_facet_skymodels_cal.control.outputkey  = outfile
make_facet_skymodels_cal.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only  = True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type       = make_sourcedb
make_sourcedb_cal_facet_sources.control.mapfile_in = make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.inputkey   = in
make_sourcedb_cal_facet_sources.argument.format    = <
make_sourcedb_cal_facet_sources.argument.outtype   = blob
make_sourcedb_cal_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind           = plugin
expand_sourcedb_cal_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in     = make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename       = expand_sourcedb_cal_facet_sources.mapfile

# shift data to calibrator position, predict and add calibrator sources, and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                 = dppp
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb]
shift_cal.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                     = True
shift_cal.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,avg]
{% endif %}
shift_cal.argument.shift.type                          = phaseshifter
shift_cal.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                            = predict
shift_cal.argument.add.sourcedb                        = sourcedb
shift_cal.argument.add.operation                       = add
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.flag.type                           = preflagger
shift_cal.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal.argument.avg.type                            = squash
shift_cal.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                        = 1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                = "Dysco"
shift_cal.argument.msout.storagemanager.databitrate    = 16
shift_cal.argument.msout.storagemanager.weightbitrate  = 12
shift_cal.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation = 1.5
shift_cal.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile.control.kind        = plugin
create_compressed_mapfile.control.type        = compressMapfile
create_compressed_mapfile.control.mapfile_in  = shift_cal.output.mapfile
create_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile.control.filename    = concat_averaged_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                 = sort_times_into_freqGroups
sort_into_Groups.argument.flags               = [create_compressed_mapfile.output.mapfile]
sort_into_Groups.argument.filename            = sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir         = input.output.mapfile_dir
sort_into_Groups.argument.hosts               = {{ hosts }}
sort_into_Groups.argument.stepname            = sort_into_Groups
sort_into_Groups.argument.enforce_numSB       = False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB               = {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad           = {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files    = True
sort_into_Groups.argument.skip_flagged_groups = False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind             = plugin
sort_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap = sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap = sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                 = dppp
concat_data.control.mapfile_out                          = sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             = msin
concat_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     = DATA
concat_data.argument.msin.missingdata                    = True
concat_data.argument.msin.orderms                        = False
concat_data.argument.msout.overwrite                     = True
concat_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_data.argument.steps                               = []
{% if use_compression %}
concat_data.argument.msout.storagemanager                = "Dysco"
concat_data.argument.msout.storagemanager.databitrate    = 16
concat_data.argument.msout.storagemanager.weightbitrate  = 12
concat_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation = 1.5
concat_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind        = plugin
concat_data_compressed_mapfile.control.type        = compressMapfile
concat_data_compressed_mapfile.control.mapfile_in  = concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename    = concat_chunks_input.mapfile

{% if selfcal_local_dir is not none %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind         = plugin
make_concat_data_sync_mapfile.control.type         = changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in   = concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir      = {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.make_tempdir = True
make_concat_data_sync_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename     = concat_data_local.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type        = sync_files
sync_concat_data_to_local.control.mapfile_in  = concat_data.output.mapfile
sync_concat_data_to_local.control.mapfile_out = make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey    = msin
sync_concat_data_to_local.control.outputkey   = msout
sync_concat_data_to_local.argument.flags      = [msin,msout]
{% endif %}

# generate mapfile for the fast-phase h5parms generated in the solve_ampphase11 step, length = ntimes * num_cal_blocks
make_fast_phase_h5parm_map.control.kind               = plugin
make_fast_phase_h5parm_map.control.type               = createMapfile
make_fast_phase_h5parm_map.control.method             = add_suffix_to_file
make_fast_phase_h5parm_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_h5parm_map.control.add_suffix_to_file = /instrument.h5
make_fast_phase_h5parm_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_h5parm_map.control.filename           = fast_h5parm.mapfile

# create a mapfile with the outlier sky model from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier sky model into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob
make_peel_sourcedb.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms1.control.type       = remove_file
remove_h5parms1.control.mapfile_in = make_fast_phase_h5parm_map.output.mapfile
remove_h5parms1.control.inputkey   = h5parm
remove_h5parms1.argument.flags     = [-rf,h5parm]

# run GainCal with peel sourcedb on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
solve_ampphase11.control.type                         = dppp_inplace
solve_ampphase11.control.mapfiles_in                  = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase11.control.inputkeys                    = [msin,h5parm,sourcedb]
solve_ampphase11.argument.numthreads                  = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn             = DATA
solve_ampphase11.argument.msout                       = .
solve_ampphase11.argument.steps                       = [solvetec]
solve_ampphase11.argument.solvetec.type               = ddecal
solve_ampphase11.argument.solvetec.mode               = tecandphase
solve_ampphase11.argument.solvetec.h5parm             = h5parm
solve_ampphase11.argument.solvetec.sourcedb           = sourcedb
solve_ampphase11.argument.solvetec.solint             = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan              = {{ solint_freq_a }}
solve_ampphase11.argument.solvetec.approximatetec     = {{ approximatetec }}
solve_ampphase11.argument.solvetec.maxapproxiter      = {{ maxapproxiter }}
solve_ampphase11.argument.solvetec.maxiter            = {{ maxiter }}
solve_ampphase11.argument.solvetec.propagatesolutions = {{ propagatesolutions }}
solve_ampphase11.argument.solvetec.stepsize           = {{ stepsize }}
solve_ampphase11.argument.solvetec.tolerance          = {{ tolerance }}
solve_ampphase11.argument.solvetec.uvlambdamin        = {{ solve_min_uv_lambda }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_h5parm_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,h5parm]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = h5parm
apply_ampphase11.argument.correct_fast1.correction            = tec000
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = h5parm
apply_ampphase11.argument.correct_fast2.correction            = phase000
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress fast-phase mapfile so that all files are in one group, length = 1
create_compressed_mapfile_fast.control.kind        = plugin
create_compressed_mapfile_fast.control.type        = compressMapfile
create_compressed_mapfile_fast.control.mapfile_in  = make_fast_phase_h5parm_map.output.mapfile
create_compressed_mapfile_fast.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_fast.control.filename    = compress_fast.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_fast_output_map.control.kind        = plugin
create_combined_fast_output_map.control.type        = addListMapfile
create_combined_fast_output_map.control.hosts       = {{ hosts }}
create_combined_fast_output_map.control.files       = [input.output.working_directory/input.output.job_name/fast_phases.h5]
create_combined_fast_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_fast_output_map.control.filename    = combine_fast_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_fast.control.kind             = plugin
match_host_fast.control.type             = matchHosts
match_host_fast.control.mapfile_in       = create_compressed_mapfile_fast.output.mapfile
match_host_fast.control.mapfile_to_match = create_combined_fast_output_map.output.mapfile
match_host_fast.control.mapfile_dir      = input.output.mapfile_dir
match_host_fast.control.filename         = match_host_slow.mapfile

# merge the h5parms with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_h5parms.control.type        = collect_h5parms
merge_phase_h5parms.control.mapfile_in  = create_compressed_mapfile_fast.output.mapfile
merge_phase_h5parms.control.inputkey    = infiles
merge_phase_h5parms.control.mapfile_out = create_combined_fast_output_map.output.mapfile
merge_phase_h5parms.control.outputkey   = outfile
merge_phase_h5parms.argument.flags      = [-c,infiles]
merge_phase_h5parms.argument.outh5parm  = outfile

# generate mapfile for the slow-gain h5parms generated in the solve_ampphase12 step, length = ntimes * num_cal_blocks
make_slow_gain_h5parm_map.control.kind               =  plugin
make_slow_gain_h5parm_map.control.type               =  createMapfile
make_slow_gain_h5parm_map.control.method             =  add_suffix_to_file
make_slow_gain_h5parm_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_h5parm_map.control.add_suffix_to_file =  /instrument_slow.h5
make_slow_gain_h5parm_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_h5parm_map.control.filename           =  slow_h5parm.mapfile

# remove any existing h5parms before solving, length = ntimes * num_cal_blocks
remove_h5parms12.control.type       = remove_file
remove_h5parms12.control.mapfile_in = make_slow_gain_h5parm_map.output.mapfile
remove_h5parms12.control.inputkey   = h5parm
remove_h5parms12.argument.flags     = [-rf,h5parm]

# run DDECal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
solve_ampphase12.control.type                            = dppp_inplace
solve_ampphase12.control.mapfiles_in                     = [{{ concat_data_mapfile }},make_slow_gain_h5parm_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase12.control.inputkeys                       = [msin,h5parm,sourcedb]
solve_ampphase12.argument.numthreads                     = {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                = CORRECTED_DATA
solve_ampphase12.argument.msout                          = .
solve_ampphase12.argument.steps                          = [solvegain]
solve_ampphase12.argument.solvegain.type                 = ddecal
solve_ampphase12.argument.solvegain.mode                 = complexgain
solve_ampphase12.argument.solvegain.h5parm               = h5parm
solve_ampphase12.argument.solvegain.sourcedb             = sourcedb
solve_ampphase12.argument.solvegain.solint               = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                = {{ solint_freq_a }}
solve_ampphase12.argument.solvegain.maxiter              = {{ maxiter }}
solve_ampphase12.argument.solvegain.propagatesolutions   = {{ propagatesolutions }}
solve_ampphase12.argument.solvegain.stepsize             = {{ stepsize }}
solve_ampphase12.argument.solvegain.tolerance            = {{ tolerance }}
solve_ampphase12.argument.solvegain.uvlambdamin          = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.smoothnessconstraint = 6e6

# compress slow-gain mapfile so that all files are in one group, length = 1
create_compressed_mapfile_slow.control.kind        = plugin
create_compressed_mapfile_slow.control.type        = compressMapfile
create_compressed_mapfile_slow.control.mapfile_in  = make_slow_gain_h5parm_map.output.mapfile
create_compressed_mapfile_slow.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_slow.control.filename    = compress_slow.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_slow_output_map.control.kind        = plugin
create_combined_slow_output_map.control.type        = addListMapfile
create_combined_slow_output_map.control.hosts       = {{ hosts }}
create_combined_slow_output_map.control.files       = [input.output.working_directory/input.output.job_name/slow_gains.h5]
create_combined_slow_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_slow_output_map.control.filename    = combine_slow_h5parms_output.mapfile

# match the host before combining, length = 1
match_host_slow.control.kind             = plugin
match_host_slow.control.type             = matchHosts
match_host_slow.control.mapfile_in       = create_compressed_mapfile_slow.output.mapfile
match_host_slow.control.mapfile_to_match = create_combined_slow_output_map.output.mapfile
match_host_slow.control.mapfile_dir      = input.output.mapfile_dir
match_host_slow.control.filename         = match_host_slow.mapfile

# collect all the slow-gain solutions, length = ntimes -> 1
combine_slow_gains1.control.type        = collect_h5parms
combine_slow_gains1.control.mapfile_in  = create_compressed_mapfile_slow.output.mapfile
combine_slow_gains1.control.inputkey    = infiles
combine_slow_gains1.control.mapfile_out = create_combined_slow_output_map.output.mapfile
combine_slow_gains1.control.outputkey   = outfile
combine_slow_gains1.argument.flags      = [-c,infiles]
combine_slow_gains1.argument.outh5parm  = outfile

# Smooth the amplitude solutions, but do not normalize them as the sky model is  // length = 1
# in absolute flux and not apparent flux
smooth_amps.control.type       = {{ smooth_amps_task }}
smooth_amps.control.mapfile_in = combine_slow_gains1.output.mapfile
smooth_amps.control.inputkey   = amph5parm
smooth_amps.argument.flags     = [amph5parm]
smooth_amps.argument.normalize = False

# Now smooth the amplitude solutions and normalize them (for use later during
# imaging of facets for peeled calibrators), length = 1
smooth_amps_normalized.control.type       = {{ smooth_amps_task }}
smooth_amps_normalized.control.mapfile_in = combine_slow_gains1.output.mapfile
smooth_amps_normalized.control.inputkey   = amph5parm
smooth_amps_normalized.argument.flags     = [amph5parm]
smooth_amps_normalized.argument.normalize = True

{% if selfcal_local_dir is not none %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type       = remove_synced_data
remove_concat_data.control.mapfile_in = make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey   = msfile
remove_concat_data.argument.flags     = [msfile]
{% endif %}

# create a mapfile for output of combine step, length = 1
create_combined_norm_output_map.control.kind        = plugin
create_combined_norm_output_map.control.type        = addListMapfile
create_combined_norm_output_map.control.hosts       = {{ hosts }}
create_combined_norm_output_map.control.files       = [input.output.working_directory/input.output.job_name/combined_solutions_norm.h5]
create_combined_norm_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_norm_output_map.control.filename    = combine_norm_h5parms_output.mapfile

# create a mapfile for output of combine step, length = 1
create_combined_unnorm_output_map.control.kind        = plugin
create_combined_unnorm_output_map.control.type        = addListMapfile
create_combined_unnorm_output_map.control.hosts       = {{ hosts }}
create_combined_unnorm_output_map.control.files       = [input.output.working_directory/input.output.job_name/combined_solutions_unnorm.h5]
create_combined_unnorm_output_map.control.mapfile_dir = input.output.mapfile_dir
create_combined_unnorm_output_map.control.filename    = combine_unnorm_h5parms_output.mapfile

# merge the phases and unnormalized amplitude h5parms, length = 2 -> 1
combine_normalized_h5parms.control.type        = combine_h5parms
combine_normalized_h5parms.control.mapfiles_in = [create_combined_fast_output_map.output.mapfile,smooth_amps_normalized.output.mapfile]
combine_normalized_h5parms.control.inputkeys   = [h1,h2]
combine_normalized_h5parms.control.mapfile_out = create_combined_norm_output_map.output.mapfile
combine_normalized_h5parms.control.outputkey   = outfile
combine_normalized_h5parms.argument.flags      = [h1,h2,outfile]

# merge the phases and unnormalized amplitude h5parms, length = 2 -> 1
combine_unnormalized_h5parms.control.type        = combine_h5parms
combine_unnormalized_h5parms.control.mapfiles_in = [create_combined_fast_output_map.output.mapfile,smooth_amps.output.mapfile]
combine_unnormalized_h5parms.control.inputkeys   = [h1,h2]
combine_unnormalized_h5parms.control.mapfile_out = create_combined_unnorm_output_map.output.mapfile
combine_unnormalized_h5parms.control.outputkey   = outfile
combine_unnormalized_h5parms.argument.flags      = [h1,h2,outfile]

{% if create_preapply_h5parm %}
# make a phase-only h5parm suitable for preapplication, length = 1
create_preapply_h5parm.control.type       = reset_amps
create_preapply_h5parm.control.mapfile_in = combine_unnormalized_h5parms.output.mapfile
create_preapply_h5parm.control.inputkey   = inh5parm
create_preapply_h5parm.control.outputkey  = outh5parm
create_preapply_h5parm.control.arguments  = [inh5parm,outh5parm]
{% endif %}

# make plots of the selfcal results (normalized) from the merged parmDB, length = 1
make_selfcal_plots.control.type       = make_selfcal_plots
make_selfcal_plots.control.mapfile_in = combine_normalized_h5parms.output.mapfile
make_selfcal_plots.control.inputkeys  = h5parm
make_selfcal_plots.control.outputkey  = plots_root
make_selfcal_plots.argument.flags     = [h5parm,plots_root]
make_selfcal_plots.argument.fourpol   = {{ fourpol }}

# expand the merged parmDB to all files, length = nfiles
expand_unnormalized_merged_h5parm_map.control.kind             = plugin
expand_unnormalized_merged_h5parm_map.control.type             = expandMapfile
expand_unnormalized_merged_h5parm_map.control.mapfile_in       = combine_unnormalized_h5parms.output.mapfile
expand_unnormalized_merged_h5parm_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_unnormalized_merged_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_unnormalized_merged_h5parm_map.control.filename         = expand_unnormalized_merged_h5parms.mapfile

# expand the normalized merged parmDB to all files, length = nfiles
expand_normalized_merged_h5parm_map.control.kind             = plugin
expand_normalized_merged_h5parm_map.control.type             = expandMapfile
expand_normalized_merged_h5parm_map.control.mapfile_in       = combine_normalized_h5parms.output.mapfile
expand_normalized_merged_h5parm_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_normalized_merged_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_normalized_merged_h5parm_map.control.filename         = expand_normalized_merged_h5parms.mapfile

# expand the calibrator peeling sourcedb to all files, length = nfiles
expand_cal_sourcedb_map.control.kind             = plugin
expand_cal_sourcedb_map.control.type             = expandMapfile
expand_cal_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_cal_sourcedb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_cal_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_cal_sourcedb_map.control.filename         = expand_sourcedb_outlier.mapfile

{% if not is_patch %}
# here we subtract the calibrator, add back the other facet sources and image

# extract the skymodel for the full facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type       = make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey   = fullmodelfile
make_facet_skymodels_all.control.outputkey  = outfile
make_facet_skymodels_all.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type       = make_sourcedb
make_sourcedb_all_facet_sources.control.mapfile_in = make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.inputkey   = in
make_sourcedb_all_facet_sources.argument.format    = <
make_sourcedb_all_facet_sources.argument.outtype   = blob
make_sourcedb_all_facet_sources.argument.append    = False

# expand the dir-indep sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           = plugin
expand_sourcedb_all_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     = make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       = expand_sourcedb_all_facet_sources.mapfile

# shift the empty data, add all facet sources, apply the direction-dependent solutions and average, length = nfiles
# compress data and weights
prepare_imaging_data.control.type                                 = dppp
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,expand_cal_sourcedb_map.output.mapfile,expand_unnormalized_merged_h5parm_map.output.mapfile,expand_normalized_merged_h5parm_map.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,sourcedb,sourcedb_cal,dir_dep_parmdb,dir_dep_parmdb_normalized]
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
prepare_imaging_data.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
prepare_imaging_data.argument.msin.startchan                      = {{ startchan_selfcal_facet_image }}
prepare_imaging_data.argument.msin.nchan                          = {{ nchan_selfcal_facet_image }}
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.steps                               = [shift,add,subtract_cal,flag,correct,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,add,subtract_cal,correct,flagzero,avg]
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ facet_ra }}deg, {{ facet_dec }}deg]
prepare_imaging_data.argument.add.type                            = predict
prepare_imaging_data.argument.add.sourcedb                        = sourcedb
prepare_imaging_data.argument.add.operation                       = add
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                             = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
prepare_imaging_data.argument.subtract_cal.type                   = predict
prepare_imaging_data.argument.subtract_cal.sourcedb               = sourcedb_cal
prepare_imaging_data.argument.subtract_cal.operation              = subtract
prepare_imaging_data.argument.subtract_cal.applycal.parmdb        = dir_dep_parmdb
prepare_imaging_data.argument.correct.type                        = applycal
prepare_imaging_data.argument.correct.parmdb                      = dir_dep_parmdb_normalized
prepare_imaging_data.argument.correct.invert                      = True
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = {{ facetimage_freqstep }}
prepare_imaging_data.argument.avg.timestep                        = {{ facetimage_timestep }}
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 16
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind        = plugin
create_compressed_mapfile5.control.type        = compressMapfile
create_compressed_mapfile5.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile5.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile5.control.filename    = concat_averaged_input.mapfile

# make a facet clean mask from the last selfcal image, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_compressed_mapfile5.output.mapfile
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.exclude_cal_region    = True
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}
premask.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [create_compressed_mapfile5.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_selfcal }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_selfcal_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
{% if nbands_selfcal_facet_image > 5 %}
wsclean_image_full.argument.fit-spectral-pol      = 5
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full.argument.multiscale-scales     = 0
wsclean_image_full.argument.weighting-rank-filter = 3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full.argument.auto-mask             = 3
wsclean_image_full.argument.auto-threshold        = 1.0
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind        = plugin
adjust_wsclean_mapfile1.control.type        = appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in  = create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename    = final_image1.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask5.control.type                = make_clean_mask
mask5.control.mapfile_in          = adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey            = imagefile
mask5.control.outputkey           = maskfile
mask5.argument.flags              = [imagefile,maskfile]
mask5.argument.region_file        = {{ region_field }}
mask5.argument.threshisl          = 6
mask5.argument.threshpix          = 8
mask5.argument.rmsbox             = (80,20)
mask5.argument.adaptive_rmsbox    = True
mask5.argument.atrous_do          = False
mask5.argument.img_format         = fits
mask5.argument.vertices_file      = {{ vertices_file }}
mask5.argument.exclude_cal_region = True
mask5.argument.dilate             = 2

# check the mask5 output and modify its mapfile if no sources were found, length = 1
check_mask_high.control.kind          = plugin
check_mask_high.control.type          = checkMapfile
check_mask_high.control.mapfile_in    = mask5.output.mapfile
check_mask_high.control.mapfile_check = mask5.output.threshold_5sig.mapfile
check_mask_high.control.mapfile_dir   = input.output.mapfile_dir
check_mask_high.control.filename      = check_mask5_map.mapfile

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model5_map.control.kind        = plugin
create_model5_map.control.type        = trimMapfile
create_model5_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-model.fits.mapfile
create_model5_map.control.trim        = -
create_model5_map.control.mapfile_dir = input.output.mapfile_dir
create_model5_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model5_map.control.kind             = plugin
expand_model5_map.control.type             = expandMapfile
expand_model5_map.control.mapfile_in       = create_model5_map.output.mapfile
expand_model5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model5_map.control.filename         = expand_model5_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask5_map.control.kind             = plugin
expand_mask5_map.control.type             = expandMapfile
expand_mask5_map.control.mapfile_in       = check_mask_high.output.mapfile
expand_mask5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask5_map.control.filename         = expand_mask5_map.mapfile

# make high-res full-facet sky model, using mask above, len = nbands
make_high_facet_skymodel.control.type        = poly2sky
make_high_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model5_map.output.mapfile,expand_mask5_map.output.mapfile]
make_high_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_high_facet_skymodel.control.outputkey   = skymodel
make_high_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

# Make a medium-res image of the facet to pick up any extended emission missed in the high-
# res image

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_high.control.type       = make_sourcedb
make_sourcedb_high.control.mapfile_in = make_new_cal_skymodel.output.mapfile
make_sourcedb_high.control.mapfile_in = make_high_facet_skymodel.output.mapfile
make_sourcedb_high.control.inputkey   = in
make_sourcedb_high.argument.format    = <
make_sourcedb_high.argument.outtype   = blob
make_sourcedb_high.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_high.control.kind           = plugin
expand_sourcedb_high.control.type           = mapfileSingleToGroup
expand_sourcedb_high.control.mapfile_in     = make_sourcedb_high.output.mapfile
expand_sourcedb_high.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_high.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_high.control.filename       = expand_sourcedb_high.mapfile

# subtract the high-resolution model, length = nfiles
# compress data and weights
subtract_high.control.type                                 = dppp
subtract_high.control.mapfiles_in                          = [prepare_imaging_data.output.mapfile,expand_sourcedb_high.output.mapfile]
subtract_high.control.inputkeys                            = [msin,sourcedb_high]
subtract_high.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
subtract_high.argument.msin.datacolumn                     = DATA
subtract_high.argument.msout.overwrite                     = True
subtract_high.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
subtract_high.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
subtract_high.argument.steps                               = [subtract,avg]
subtract_high.argument.subtract.type                       = predict
subtract_high.argument.subtract.sourcedb                   = sourcedb_high
subtract_high.argument.subtract.operation                  = subtract
subtract_high.argument.avg.type                            = squash
subtract_high.argument.avg.freqstep                        = {{ facetimage_low_freqstep }}
subtract_high.argument.avg.timestep                        = {{ facetimage_low_timestep }}
{% if use_compression %}
subtract_high.argument.msout.storagemanager                = "Dysco"
subtract_high.argument.msout.storagemanager.databitrate    = 0
subtract_high.argument.msout.storagemanager.weightbitrate  = 12
subtract_high.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
subtract_high.argument.msout.storagemanager.disttruncation = 1.5
subtract_high.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile6.control.kind        = plugin
create_compressed_mapfile6.control.type        = compressMapfile
create_compressed_mapfile6.control.mapfile_in  = subtract_high.output.mapfile
create_compressed_mapfile6.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile6.control.filename    = concat_averaged_med_input.mapfile

# Make a facet clean mask from the facet region, length = 1
premask_med.control.type                   = make_clean_mask
premask_med.control.mapfile_in             = create_compressed_mapfile6.output.mapfile
premask_med.control.inputkey               = imagefile
premask_med.control.outputkey              = maskfile
premask_med.argument.flags                 = [imagefile,maskfile]
premask_med.argument.img_format            = fits
premask_med.argument.pad_to_size           = {{ facet_med_imsize }}
premask_med.argument.skip_source_detection = True
premask_med.argument.vertices_file         = {{ vertices_file }}
premask_med.argument.reference_ra_deg      = {{ facet_ra }}
premask_med.argument.reference_dec_deg     = {{ facet_dec }}
premask_med.argument.cellsize_deg          = {{ cellsize_facet_med_deg }}
premask_med.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask at med resolution, length = 1
wsclean_image_full_med.control.type                   = wsclean
wsclean_image_full_med.control.mapfiles_in            = [create_compressed_mapfile6.output.mapfile,premask_med.output.mapfile]
wsclean_image_full_med.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full_med.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full_med.argument.fitsmask              = fitsmask
wsclean_image_full_med.argument.size                  = {{ facet_med_imsize }} {{ facet_med_imsize }}
wsclean_image_full_med.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full_med.argument.pol                   = I
wsclean_image_full_med.argument.weight                = briggs 0.0
wsclean_image_full_med.argument.mgain                 = 0.8
wsclean_image_full_med.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full_med.argument.taper-gaussian        = {{ cellsize_facet_med_deg*3600*3 }}arcsec
wsclean_image_full_med.argument.scale                 = {{ cellsize_facet_med_deg }}
wsclean_image_full_med.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full_med.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full_med.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full_med.argument.multiscale-shape      = gaussian
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full_med.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full_med.argument.weighting-rank-filter = 3
{% if facetimage_medlow_wsclean_nwavelengths > 0.0 %}
wsclean_image_full_med.argument.baseline-averaging    = {{ facetimage_medlow_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full_med.argument.auto-mask             = 3
wsclean_image_full_med.argument.auto-threshold        = 0.5
wsclean_image_full_med.argument.local-rms-window      = 50
wsclean_image_full_med.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_med_map.control.kind        = plugin
create_imagebase_med_map.control.type        = trimMapfile
create_imagebase_med_map.control.mapfile_in  = wsclean_image_full_med.output.wsclean_image_full_med-image.fits.mapfile
create_imagebase_med_map.control.trim        = -
create_imagebase_med_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_med_map.control.filename    = wsclean_image_full_med_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile3.control.kind        = plugin
adjust_wsclean_mapfile3.control.type        = appendMapfile
adjust_wsclean_mapfile3.control.mapfile_in  = create_imagebase_med_map.output.mapfile
adjust_wsclean_mapfile3.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile3.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile3.control.filename    = final_image_med.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask6.control.type                = make_clean_mask
mask6.control.mapfile_in          = adjust_wsclean_mapfile3.output.mapfile
mask6.control.inputkey            = imagefile
mask6.control.outputkey           = maskfile
mask6.argument.flags              = [imagefile,maskfile]
mask6.argument.region_file        = {{ region_field }}
mask6.argument.threshisl          = 5
mask6.argument.threshpix          = 8
mask6.argument.rmsbox             = (80,20)
mask6.argument.adaptive_rmsbox    = True
mask6.argument.atrous_do          = True
mask6.argument.img_format         = fits
mask6.argument.vertices_file      = {{ vertices_file }}
mask6.argument.exclude_cal_region = False
mask6.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_med.control.kind          = plugin
check_mask_med.control.type          = checkMapfile
check_mask_med.control.mapfile_in    = mask6.output.mapfile
check_mask_med.control.mapfile_check = mask6.output.threshold_5sig.mapfile
check_mask_med.control.mapfile_dir   = input.output.mapfile_dir
check_mask_med.control.filename      = check_mask6_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model6_map.control.kind             = plugin
expand_model6_map.control.type             = expandMapfile
expand_model6_map.control.mapfile_in       = create_imagebase_med_map.output.mapfile
expand_model6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model6_map.control.filename         = expand_model6_map.mapfile

# expand the mask mapfile so that there is one entry for every band, length = nbands
expand_mask6_map.control.kind             = plugin
expand_mask6_map.control.type             = expandMapfile
expand_mask6_map.control.mapfile_in       = check_mask_med.output.mapfile
expand_mask6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask6_map.control.filename         = expand_mask6_map.mapfile

# make med-res full-facet sky model, using mask above, len = nbands
make_med_facet_skymodel.control.type        = poly2sky
make_med_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model6_map.output.mapfile,expand_mask6_map.output.mapfile]
make_med_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_med_facet_skymodel.control.outputkey   = skymodel
make_med_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask,0.0,0.0]

# combine the medium- and high-res facet sky models, length = nbands
combine_facet_skymodels.control.type        = combine_skymodels
combine_facet_skymodels.control.mapfiles_in = [make_high_facet_skymodel.output.mapfile,make_med_facet_skymodel.output.mapfile]
combine_facet_skymodels.control.inputkeys   = [highresmodel,medresmodel]
combine_facet_skymodels.control.outputkey   = skymodel
combine_facet_skymodels.argument.flags      = [highresmodel,medresmodel,skymodel]

# convert the combined sky model for facet imaging into a sourcedb, length = nbands
make_sourcedb_new_facet_sources_for_facet_imaging.control.type       = make_sourcedb
make_sourcedb_new_facet_sources_for_facet_imaging.control.mapfile_in = combine_facet_skymodels.output.mapfile
make_sourcedb_new_facet_sources_for_facet_imaging.control.inputkey   = in
make_sourcedb_new_facet_sources_for_facet_imaging.argument.format    = <
make_sourcedb_new_facet_sources_for_facet_imaging.argument.outtype   = blob
make_sourcedb_new_facet_sources_for_facet_imaging.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources_for_facet_imaging.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" block

# predict the old and new models and subtract the old one from the new one, length = nfiles
# compress weights only
predict_and_difference_models.control.type                                 = dppp
{% if not is_patch %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_normalized_merged_h5parm_map.output.mapfile,expand_cal_sourcedb_map.output.mapfile,expand_unnormalized_merged_h5parm_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,facet_sourcedb,dir_dep_parmdb_normalized,cal_sourcedb,dir_dep_parmdb_unnormalized,dir_indep_sourcedb]
{% else %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_cal_sourcedb_map.output.mapfile,expand_unnormalized_merged_h5parm_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,cal_sourcedb,dir_dep_parmdb_unnormalized,dir_indep_sourcedb]
{% endif %}
predict_and_difference_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
predict_and_difference_models.argument.msin.datacolumn                     = DATA
predict_and_difference_models.argument.msout.overwrite                     = True
predict_and_difference_models.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
predict_and_difference_models.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if not is_patch %}
predict_and_difference_models.argument.steps                               = [pred_cal,pred_facet,subtract_old]
predict_and_difference_models.argument.pred_facet.type                     = predict
predict_and_difference_models.argument.pred_facet.sourcedb                 = facet_sourcedb
predict_and_difference_models.argument.pred_facet.applycal.parmdb          = dir_dep_parmdb_normalized
predict_and_difference_models.argument.pred_facet.operation                = add
{% else %}
predict_and_difference_models.argument.steps                               = [pred_cal,subtract_old]
{% endif %}
predict_and_difference_models.argument.pred_cal.type                       = predict
predict_and_difference_models.argument.pred_cal.sourcedb                   = cal_sourcedb
predict_and_difference_models.argument.pred_cal.applycal.parmdb            = dir_dep_parmdb_unnormalized
predict_and_difference_models.argument.pred_cal.operation                  = replace
predict_and_difference_models.argument.subtract_old.type                   = predict
predict_and_difference_models.argument.subtract_old.sourcedb               = dir_indep_sourcedb
predict_and_difference_models.argument.subtract_old.operation              = subtract
{% if use_compression %}
predict_and_difference_models.argument.msout.storagemanager                = "Dysco"
predict_and_difference_models.argument.msout.storagemanager.databitrate    = 0
predict_and_difference_models.argument.msout.storagemanager.weightbitrate  = 12
predict_and_difference_models.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
predict_and_difference_models.argument.msout.storagemanager.disttruncation = 1.5
predict_and_difference_models.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

#
# Verify the quality of selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile1.control.kind        = plugin
create_middle_band_mapfile1.control.type        = selectMiddleFreq
create_middle_band_mapfile1.control.mapfile_in  = create_ms_map.output.mapfile
create_middle_band_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile1.control.filename    = single_band_orig.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile2.control.kind        = plugin
create_middle_band_mapfile2.control.type        = selectMiddleFreq
create_middle_band_mapfile2.control.mapfile_in  = predict_and_difference_models.output.mapfile
create_middle_band_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile2.control.filename    = single_band_new.mapfile

# subtract new facet data from original data, length = ntimes
subtract_single.control.type        = add_subtract_columns
subtract_single.control.mapfiles_in = [create_middle_band_mapfile2.output.mapfile,create_middle_band_mapfile1.output.mapfile]
subtract_single.control.inputkeys   = [file1,file2]
subtract_single.argument.flags      = [file1,file2,DATA,{{ subtracted_data_colname }},MODEL_DATA,subtract21]

# average old empty data, length = ntimes
average_pre.control.type                                 = dppp
average_pre.control.mapfile_in                           = create_middle_band_mapfile1.output.mapfile
average_pre.control.inputkey                             = msin
average_pre.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
average_pre.argument.msout.overwrite                     = True
average_pre.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_pre.argument.steps                               = [uv,avg]
average_pre.argument.uv.type                             = uvwflagger
average_pre.argument.uv.uvmmax                           = 2500.0
average_pre.argument.avg.type                            = squash
average_pre.argument.avg.freqstep                        = {{ verify_freqstep }}
average_pre.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                = "Dysco"
average_pre.argument.msout.storagemanager.databitrate    = 16
average_pre.argument.msout.storagemanager.weightbitrate  = 12
average_pre.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation = 1.5
average_pre.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                 = dppp
average_post.control.mapfile_in                           = create_middle_band_mapfile2.output.mapfile
average_post.control.inputkey                             = msin
average_post.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                     = MODEL_DATA
average_post.argument.msout.overwrite                     = True
average_post.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_post.argument.steps                               = [uv,avg]
average_post.argument.uv.type                             = uvwflagger
average_post.argument.uv.uvmmax                           = 2500.0
average_post.argument.avg.type                            = squash
average_post.argument.avg.freqstep                        = {{ verify_freqstep }}
average_post.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                = "Dysco"
average_post.argument.msout.storagemanager.databitrate    = 16
average_post.argument.msout.storagemanager.weightbitrate  = 12
average_post.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation = 1.5
average_post.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind        = plugin
average_pre_compressed_map.control.type        = compressMapfile
average_pre_compressed_map.control.mapfile_in  = average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_pre_compressed_map.control.filename    = average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type         = wsclean
wsclean_pre.control.mapfile_in   = average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey     = msfiles
wsclean_pre.argument.flags       = [-no-update-model-required,msfiles]
wsclean_pre.argument.size        = 2048 2048
wsclean_pre.argument.niter       = 10
wsclean_pre.argument.threshold   = 0.0
wsclean_pre.argument.pol         = I
wsclean_pre.argument.weight      = briggs -0.5
wsclean_pre.argument.mgain       = 0.8
wsclean_pre.argument.gain        = 0.1
wsclean_pre.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l     = 2500
wsclean_pre.argument.scale       = 0.00833
wsclean_pre.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind        = plugin
average_post_compressed_map.control.type        = compressMapfile
average_post_compressed_map.control.mapfile_in  = average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_post_compressed_map.control.filename    = average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type         = wsclean
wsclean_post.control.mapfile_in   = average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey     = msfiles
wsclean_post.argument.flags       = [-no-update-model-required,msfiles]
wsclean_post.argument.size        = 2048 2048
wsclean_post.argument.niter       = 10
wsclean_post.argument.threshold   = 0.0
wsclean_post.argument.pol         = I
wsclean_post.argument.weight      = briggs -0.5
wsclean_post.argument.mgain       = 0.8
wsclean_post.argument.gain        = 0.1
wsclean_post.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l     = 2500
wsclean_post.argument.scale       = 0.00833
wsclean_post.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type        = verify_subtract
verify_subtract.control.mapfiles_in = [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys   = [image_pre,image_post]
verify_subtract.argument.flags      = [image_pre,image_post,0.75]
